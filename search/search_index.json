{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Fake Store Data Pipeline","text":"<p>Este projeto de Engenharia de Dados realiza o processamento de dados da Fake Store API, convertendo-os para formatos utiliz\u00e1veis e criando uma pipeline de dados robusta, automatizada e pronta para an\u00e1lise. O fluxo de trabalho abrange desde a ingest\u00e3o de dados brutos at\u00e9 a visualiza\u00e7\u00e3o dos dados em dashboards interativos.</p>"},{"location":"#objetivos-do-projeto","title":"Objetivos do Projeto","text":"<ul> <li>Ingest\u00e3o de Dados: Consumir dados da Fake Store API e armazen\u00e1-los de forma eficiente.</li> <li>Transforma\u00e7\u00e3o: Processar os dados para extrair informa\u00e7\u00f5es relevantes sobre os usu\u00e1rios e seus produtos no carrinho.</li> <li>Persist\u00eancia: Armazenar os dados transformados em um formato otimizado para consultas futuras.</li> <li>Automatiza\u00e7\u00e3o: Implementar o desenho de um fluxo de trabalho que ser\u00e1 excutado diariamente.</li> <li>Visualiza\u00e7\u00e3o: Criar um web app utilizando Streamlit para visualiza\u00e7\u00e3o dos dados e gera\u00e7\u00e3o de relat\u00f3rios<ul> <li>O arquivo gerado deve conter:<ul> <li>identificador de usu\u00e1rio</li> <li>data mais recente em que o usu\u00e1rio adicionou produtos ao carrinho</li> <li>categoria em que o usu\u00e1rio tem mais produtos adicionados ao carrinho</li> </ul> </li> </ul> </li> </ul>"},{"location":"#fluxo-do-projeto","title":"Fluxo do Projeto","text":""},{"location":"#estrutura-do-pipeline","title":"Estrutura do Pipeline","text":"<ol> <li> <p><code>Camada Raw</code>: Nesta camada, os dados brutos s\u00e3o armazenados em arquivos <code>.json</code> provenientes da Fake Store API. A cada execu\u00e7\u00e3o do pipeline, um novo arquivo \u00e9 gerado, permitindo o armazenamento de um hist\u00f3rico de extra\u00e7\u00f5es.</p> </li> <li> <p><code>Camada Silver</code>: Os dados brutos s\u00e3o transformados e armazenados em um banco de dados SQLite. Uma modelagem de dados \u00e9 criada para refletir as rela\u00e7\u00f5es necess\u00e1rias, permitindo consultas eficientes.</p> </li> <li> <p><code>Camada Gold</code>: Nesta camada, os dados s\u00e3o desnormalizados e organizados em tabelas otimizadas para an\u00e1lise.</p> </li> <li> <p><code>Visualiza\u00e7\u00e3o</code>: Um web app desenvolvido com Streamlit permite que os usu\u00e1rios visualizem os dados e fa\u00e7am download de relat\u00f3rios em formato CSV. Link para o webapp: https://fakestore.streamlit.app/</p> </li> </ol> Nota <p>O arquivo <code>user_cart_insights.csv</code> tamb\u00e9m pode ser encontrado em: data/marts/</p>"},{"location":"data_extractor/","title":"Documenta\u00e7\u00e3o da classe DataExtractor","text":""},{"location":"data_extractor/#fake_store.data_extractor.DataExtractor","title":"<code>fake_store.data_extractor.DataExtractor</code>","text":"<p>Classe respons\u00e1vel por extrair, validar e salvar dados de uma API.</p> Source code in <code>fake_store/data_extractor.py</code> <pre><code>class DataExtractor:\n    \"\"\"Classe respons\u00e1vel por extrair, validar e salvar dados de uma API.\"\"\"\n\n    BASE_API_URL = \"https://fakestoreapi.com\"\n\n    @staticmethod\n    def fetch_data(endpoint: str) -&gt; List[dict]:\n        \"\"\"\n        Faz uma requisi\u00e7\u00e3o GET para buscar dados da API no endpoint fornecido.\n\n        Args:\n            endpoint (str): O URL do endpoint da API a ser acessado.\n\n        Returns:\n            List[dict]: Uma lista de dicion\u00e1rios contendo os dados retornados.\n\n        Raises:\n            requests.HTTPError: Caso a resposta da API tenha um erro HTTP.\n            requests.RequestException: Para qualquer outro erro de requisi\u00e7\u00e3o.\n        \"\"\"\n        logging.info(f\"Buscando dados de: {endpoint}\")\n        try:\n            response = requests.get(endpoint)\n            response.raise_for_status()\n            logging.info(\"Dados recebidos com sucesso.\")\n            return response.json()\n        except requests.HTTPError as http_err:\n            logging.error(f\"Erro HTTP ao buscar dados: {http_err}\")\n            raise\n        except requests.RequestException as e:\n            logging.error(f\"Erro ao buscar dados: {e}\")\n            raise\n\n    @staticmethod\n    def validate_data(data: List[dict], data_type: str) -&gt; List[dict]:\n        \"\"\"\n        Valida e filtra dados recebidos da API de acordo com o tipo.\n\n        Args:\n            data (List[dict]): Lista de dados n\u00e3o validados da API.\n            data_type (str): O tipo de dados a serem validados\n                             (\"categories\", \"products\", \"users\" ou \"carts\").\n\n        Returns:\n            List[dict]: Lista de dados validados e prontos para serializa\u00e7\u00e3o.\n\n        Raises:\n            ValidationError: Em caso de erro na valida\u00e7\u00e3o dos dados de entrada.\n        \"\"\"\n        validated_data = []\n        if data_type == \"categories\":\n            if isinstance(data, list):\n                try:\n                    validated_item = Categories(category=data)\n                    validated_data.append(validated_item.model_dump())\n                except ValidationError as e:\n                    logging.warning(f\"Erro de valida\u00e7\u00e3o: {e}\")\n        else:\n            for item in data:\n                try:\n                    if data_type == \"products\":\n                        validated_item = Product(**item)\n                    elif data_type == \"users\":\n                        validated_item = User(**item)\n                    elif data_type == \"carts\":\n                        validated_item = Cart(**item)\n\n                    validated_data.append(validated_item.model_dump())\n                except ValidationError as e:\n                    logging.warning(\n                        f\"Erro de valida\u00e7\u00e3o para o item {item}: {e}\"\n                    )\n\n        logging.info(f\"{len(validated_data)} dados validados com sucesso.\")\n        return validated_data\n\n    @staticmethod\n    def serialize_data(data: List[dict]) -&gt; List[Dict[str, Any]]:\n        \"\"\"\n        Converte objetos de dados para um formato JSON serializ\u00e1vel,\n        especialmente datas.\n\n        Args:\n            data (List[dict]): Lista de dicion\u00e1rios de dados a serem\n                               serializados.\n\n        Returns:\n            List[Dict[str, Any]]: Lista de dados serializados prontos para\n                                  armazenamento.\n\n        Raises:\n            TypeError: Caso um objeto n\u00e3o seja serializ\u00e1vel para JSON.\n        \"\"\"\n\n        def convert_datetime(obj):\n            if isinstance(obj, datetime):\n                return obj.isoformat()\n            raise TypeError(\n                f\"Object of type {type(obj)} is not JSON serializable\"\n            )\n\n        return [\n            {\n                k: convert_datetime(v) if isinstance(v, (datetime,)) else v\n                for k, v in item.items()\n            }\n            for item in data\n        ]\n\n    @staticmethod\n    def save_to_json(data: List[dict], endpoint: str):\n        \"\"\"\n        Salva os dados validados em um arquivo JSON, organizando-os em\n        pastas por data.\n\n        Args:\n            data (List[dict]): Lista de dados validados a serem salvos.\n            endpoinl (str): Nome do endpoint ou tipo de dados, usado para\n                            nomear o arquivo.\n\n        Raises:\n            OSError: Caso ocorra um erro ao criar o diret\u00f3rio ou ao salvar o arquivo.\n        \"\"\"\n        if not data:\n            logging.info(\"Nenhum dado para salvar.\")\n            return\n\n        current_date = datetime.now()\n        folder_path = (\n            f\"data/raw/{current_date.year}/\"\n            f\"{current_date.month:02}/{current_date.day:02}\"\n        )\n        os.makedirs(folder_path, exist_ok=True)\n\n        timestamp = current_date.strftime(\"%Y%m%d%H%M%S\")\n        filename = f\"{folder_path}/{endpoint}_{timestamp}.json\"\n\n        serialized_data = DataExtractor.serialize_data(data)\n\n        try:\n            with open(filename, \"w\", encoding=\"utf-8\") as json_file:\n                json.dump(serialized_data, json_file, indent=4)\n            logging.info(f\"Dados salvos em: {filename}\")\n        except Exception as e:\n            logging.error(f\"Erro ao salvar os dados em JSON: {e}\")\n\n    @classmethod\n    def run_data_extraction(cls, data_type: str):\n        \"\"\"\n        Executa o processo completo de extra\u00e7\u00e3o de dados: busca, valida\u00e7\u00e3o e\n        salvamento.\n\n        Args:\n            data_type (str): O tipo de dados a serem extra\u00eddos\n                             (\"products\", \"users\", \"carts\", \"categories\").\n\n        Raises:\n            requests.RequestException: Para erros de rede ao buscar os dados.\n            ValidationError: Para erros de valida\u00e7\u00e3o dos dados recebidos.\n        \"\"\"\n        endpoint_map = {\n            \"products\": f\"{cls.BASE_API_URL}/products\",\n            \"users\": f\"{cls.BASE_API_URL}/users\",\n            \"carts\": f\"{cls.BASE_API_URL}/carts\",\n            \"categories\": f\"{cls.BASE_API_URL}/products/categories\",\n        }\n        endpoint = endpoint_map.get(data_type)\n        if not endpoint:\n            logging.error(f\"Tipo de dados inv\u00e1lido: {data_type}\")\n            return\n\n        try:\n            data = cls.fetch_data(endpoint)\n            validated_data = cls.validate_data(data, data_type)\n            cls.save_to_json(validated_data, data_type)\n        except (requests.RequestException, ValidationError) as e:\n            logging.error(f\"Ocorreu um erro na execu\u00e7\u00e3o para {data_type}: {e}\")\n</code></pre>"},{"location":"data_extractor/#fake_store.data_extractor.DataExtractor.fetch_data","title":"<code>fetch_data(endpoint)</code>  <code>staticmethod</code>","text":"<p>Faz uma requisi\u00e7\u00e3o GET para buscar dados da API no endpoint fornecido.</p> <p>Parameters:</p> Name Type Description Default <code>endpoint</code> <code>str</code> <p>O URL do endpoint da API a ser acessado.</p> required <p>Returns:</p> Type Description <code>List[dict]</code> <p>List[dict]: Uma lista de dicion\u00e1rios contendo os dados retornados.</p> <p>Raises:</p> Type Description <code>HTTPError</code> <p>Caso a resposta da API tenha um erro HTTP.</p> <code>RequestException</code> <p>Para qualquer outro erro de requisi\u00e7\u00e3o.</p> Source code in <code>fake_store/data_extractor.py</code> <pre><code>@staticmethod\ndef fetch_data(endpoint: str) -&gt; List[dict]:\n    \"\"\"\n    Faz uma requisi\u00e7\u00e3o GET para buscar dados da API no endpoint fornecido.\n\n    Args:\n        endpoint (str): O URL do endpoint da API a ser acessado.\n\n    Returns:\n        List[dict]: Uma lista de dicion\u00e1rios contendo os dados retornados.\n\n    Raises:\n        requests.HTTPError: Caso a resposta da API tenha um erro HTTP.\n        requests.RequestException: Para qualquer outro erro de requisi\u00e7\u00e3o.\n    \"\"\"\n    logging.info(f\"Buscando dados de: {endpoint}\")\n    try:\n        response = requests.get(endpoint)\n        response.raise_for_status()\n        logging.info(\"Dados recebidos com sucesso.\")\n        return response.json()\n    except requests.HTTPError as http_err:\n        logging.error(f\"Erro HTTP ao buscar dados: {http_err}\")\n        raise\n    except requests.RequestException as e:\n        logging.error(f\"Erro ao buscar dados: {e}\")\n        raise\n</code></pre>"},{"location":"data_extractor/#fake_store.data_extractor.DataExtractor.run_data_extraction","title":"<code>run_data_extraction(data_type)</code>  <code>classmethod</code>","text":"<p>Executa o processo completo de extra\u00e7\u00e3o de dados: busca, valida\u00e7\u00e3o e salvamento.</p> <p>Parameters:</p> Name Type Description Default <code>data_type</code> <code>str</code> <p>O tipo de dados a serem extra\u00eddos              (\"products\", \"users\", \"carts\", \"categories\").</p> required <p>Raises:</p> Type Description <code>RequestException</code> <p>Para erros de rede ao buscar os dados.</p> <code>ValidationError</code> <p>Para erros de valida\u00e7\u00e3o dos dados recebidos.</p> Source code in <code>fake_store/data_extractor.py</code> <pre><code>@classmethod\ndef run_data_extraction(cls, data_type: str):\n    \"\"\"\n    Executa o processo completo de extra\u00e7\u00e3o de dados: busca, valida\u00e7\u00e3o e\n    salvamento.\n\n    Args:\n        data_type (str): O tipo de dados a serem extra\u00eddos\n                         (\"products\", \"users\", \"carts\", \"categories\").\n\n    Raises:\n        requests.RequestException: Para erros de rede ao buscar os dados.\n        ValidationError: Para erros de valida\u00e7\u00e3o dos dados recebidos.\n    \"\"\"\n    endpoint_map = {\n        \"products\": f\"{cls.BASE_API_URL}/products\",\n        \"users\": f\"{cls.BASE_API_URL}/users\",\n        \"carts\": f\"{cls.BASE_API_URL}/carts\",\n        \"categories\": f\"{cls.BASE_API_URL}/products/categories\",\n    }\n    endpoint = endpoint_map.get(data_type)\n    if not endpoint:\n        logging.error(f\"Tipo de dados inv\u00e1lido: {data_type}\")\n        return\n\n    try:\n        data = cls.fetch_data(endpoint)\n        validated_data = cls.validate_data(data, data_type)\n        cls.save_to_json(validated_data, data_type)\n    except (requests.RequestException, ValidationError) as e:\n        logging.error(f\"Ocorreu um erro na execu\u00e7\u00e3o para {data_type}: {e}\")\n</code></pre>"},{"location":"data_extractor/#fake_store.data_extractor.DataExtractor.save_to_json","title":"<code>save_to_json(data, endpoint)</code>  <code>staticmethod</code>","text":"<p>Salva os dados validados em um arquivo JSON, organizando-os em pastas por data.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>List[dict]</code> <p>Lista de dados validados a serem salvos.</p> required <code>endpoinl</code> <code>str</code> <p>Nome do endpoint ou tipo de dados, usado para             nomear o arquivo.</p> required <p>Raises:</p> Type Description <code>OSError</code> <p>Caso ocorra um erro ao criar o diret\u00f3rio ou ao salvar o arquivo.</p> Source code in <code>fake_store/data_extractor.py</code> <pre><code>@staticmethod\ndef save_to_json(data: List[dict], endpoint: str):\n    \"\"\"\n    Salva os dados validados em um arquivo JSON, organizando-os em\n    pastas por data.\n\n    Args:\n        data (List[dict]): Lista de dados validados a serem salvos.\n        endpoinl (str): Nome do endpoint ou tipo de dados, usado para\n                        nomear o arquivo.\n\n    Raises:\n        OSError: Caso ocorra um erro ao criar o diret\u00f3rio ou ao salvar o arquivo.\n    \"\"\"\n    if not data:\n        logging.info(\"Nenhum dado para salvar.\")\n        return\n\n    current_date = datetime.now()\n    folder_path = (\n        f\"data/raw/{current_date.year}/\"\n        f\"{current_date.month:02}/{current_date.day:02}\"\n    )\n    os.makedirs(folder_path, exist_ok=True)\n\n    timestamp = current_date.strftime(\"%Y%m%d%H%M%S\")\n    filename = f\"{folder_path}/{endpoint}_{timestamp}.json\"\n\n    serialized_data = DataExtractor.serialize_data(data)\n\n    try:\n        with open(filename, \"w\", encoding=\"utf-8\") as json_file:\n            json.dump(serialized_data, json_file, indent=4)\n        logging.info(f\"Dados salvos em: {filename}\")\n    except Exception as e:\n        logging.error(f\"Erro ao salvar os dados em JSON: {e}\")\n</code></pre>"},{"location":"data_extractor/#fake_store.data_extractor.DataExtractor.serialize_data","title":"<code>serialize_data(data)</code>  <code>staticmethod</code>","text":"<p>Converte objetos de dados para um formato JSON serializ\u00e1vel, especialmente datas.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>List[dict]</code> <p>Lista de dicion\u00e1rios de dados a serem                serializados.</p> required <p>Returns:</p> Type Description <code>List[Dict[str, Any]]</code> <p>List[Dict[str, Any]]: Lista de dados serializados prontos para                   armazenamento.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>Caso um objeto n\u00e3o seja serializ\u00e1vel para JSON.</p> Source code in <code>fake_store/data_extractor.py</code> <pre><code>@staticmethod\ndef serialize_data(data: List[dict]) -&gt; List[Dict[str, Any]]:\n    \"\"\"\n    Converte objetos de dados para um formato JSON serializ\u00e1vel,\n    especialmente datas.\n\n    Args:\n        data (List[dict]): Lista de dicion\u00e1rios de dados a serem\n                           serializados.\n\n    Returns:\n        List[Dict[str, Any]]: Lista de dados serializados prontos para\n                              armazenamento.\n\n    Raises:\n        TypeError: Caso um objeto n\u00e3o seja serializ\u00e1vel para JSON.\n    \"\"\"\n\n    def convert_datetime(obj):\n        if isinstance(obj, datetime):\n            return obj.isoformat()\n        raise TypeError(\n            f\"Object of type {type(obj)} is not JSON serializable\"\n        )\n\n    return [\n        {\n            k: convert_datetime(v) if isinstance(v, (datetime,)) else v\n            for k, v in item.items()\n        }\n        for item in data\n    ]\n</code></pre>"},{"location":"data_extractor/#fake_store.data_extractor.DataExtractor.validate_data","title":"<code>validate_data(data, data_type)</code>  <code>staticmethod</code>","text":"<p>Valida e filtra dados recebidos da API de acordo com o tipo.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>List[dict]</code> <p>Lista de dados n\u00e3o validados da API.</p> required <code>data_type</code> <code>str</code> <p>O tipo de dados a serem validados              (\"categories\", \"products\", \"users\" ou \"carts\").</p> required <p>Returns:</p> Type Description <code>List[dict]</code> <p>List[dict]: Lista de dados validados e prontos para serializa\u00e7\u00e3o.</p> <p>Raises:</p> Type Description <code>ValidationError</code> <p>Em caso de erro na valida\u00e7\u00e3o dos dados de entrada.</p> Source code in <code>fake_store/data_extractor.py</code> <pre><code>@staticmethod\ndef validate_data(data: List[dict], data_type: str) -&gt; List[dict]:\n    \"\"\"\n    Valida e filtra dados recebidos da API de acordo com o tipo.\n\n    Args:\n        data (List[dict]): Lista de dados n\u00e3o validados da API.\n        data_type (str): O tipo de dados a serem validados\n                         (\"categories\", \"products\", \"users\" ou \"carts\").\n\n    Returns:\n        List[dict]: Lista de dados validados e prontos para serializa\u00e7\u00e3o.\n\n    Raises:\n        ValidationError: Em caso de erro na valida\u00e7\u00e3o dos dados de entrada.\n    \"\"\"\n    validated_data = []\n    if data_type == \"categories\":\n        if isinstance(data, list):\n            try:\n                validated_item = Categories(category=data)\n                validated_data.append(validated_item.model_dump())\n            except ValidationError as e:\n                logging.warning(f\"Erro de valida\u00e7\u00e3o: {e}\")\n    else:\n        for item in data:\n            try:\n                if data_type == \"products\":\n                    validated_item = Product(**item)\n                elif data_type == \"users\":\n                    validated_item = User(**item)\n                elif data_type == \"carts\":\n                    validated_item = Cart(**item)\n\n                validated_data.append(validated_item.model_dump())\n            except ValidationError as e:\n                logging.warning(\n                    f\"Erro de valida\u00e7\u00e3o para o item {item}: {e}\"\n                )\n\n    logging.info(f\"{len(validated_data)} dados validados com sucesso.\")\n    return validated_data\n</code></pre>"},{"location":"find_recent_data/","title":"Encontra os arquivos com data mais recente","text":""},{"location":"find_recent_data/#fake_store.find_recent_data","title":"<code>fake_store.find_recent_data</code>","text":""},{"location":"find_recent_data/#fake_store.find_recent_data.FindRecentData","title":"<code>FindRecentData</code>","text":"Source code in <code>fake_store/find_recent_data.py</code> <pre><code>class FindRecentData:\n    def __init__(self, base_dir):\n        \"\"\"\n        Inicializa a classe FindRecentData com o diret\u00f3rio base onde os dados\n        est\u00e3o armazenados, organizado por ano, m\u00eas e dia.\n\n        Parameters:\n            base_dir (str): Caminho para o diret\u00f3rio base contendo os arquivos.\n        \"\"\"\n        self.base_dir = base_dir\n        logging.info(f\"Iniciando DataIngestion com base_dir: {self.base_dir}\")\n\n    def buscar_arquivos_recentes(self):\n        \"\"\"\n        Busca os arquivos mais recentes para cada tipo de dado\n        (carts, products, users, categories)\n        com base na estrutura de diret\u00f3rios de ano,m\u00eas e dia.\n\n        returns:\n            tuple: Caminhos para os arquivos mais recentes de cada tipo,\n                    ou None se n\u00e3o existirem arquivos para um tipo espec\u00edfico.\n        \"\"\"\n        ano_recentes = self.obter_ano_recentes()\n        if ano_recentes is None:\n            logging.warning(\"Nenhum ano encontrado.\")\n            return self._get_empty_results()\n\n        mes_recentes = self.obter_mes_recentes(ano_recentes)\n        if mes_recentes is None:\n            logging.warning(\n                f\"Nenhum m\u00eas encontrado para o ano {ano_recentes}.\"\n            )\n            return self._get_empty_results()\n\n        dia_recentes_path = self.obter_dia_recentes_path(\n            ano_recentes, mes_recentes\n        )\n        if dia_recentes_path is None:\n            logging.warning(\n                f\"\"\"Nenhum dia encontrado para o m\u00eas\n                {mes_recentes} do ano {ano_recentes}.\"\"\"\n            )\n            return self._get_empty_results()\n\n        return (\n            self.buscar_carts(dia_recentes_path),\n            self.buscar_products(dia_recentes_path),\n            self.buscar_users(dia_recentes_path),\n            self.buscar_categories(dia_recentes_path),\n        )\n\n    def buscar_carts(self, dia_recentes_path):\n        \"\"\"\n        Busca o arquivo mais recente do tipo 'carts' no diret\u00f3rio especificado.\n\n        parameters:\n            dia_recentes_path (str): Caminho para o diret\u00f3rio\n                                     do dia mais recente.\n\n        returns:\n            str: Caminho do arquivo mais recente de 'carts',\n                 ou None se n\u00e3o encontrado.\n        \"\"\"\n        return self.buscar_arquivo_por_tipo(dia_recentes_path, FileType.CARTS)\n\n    def buscar_products(self, dia_recentes_path):\n        \"\"\"\n        Busca o arquivo mais recente do tipo 'products'\n        no diret\u00f3rio especificado.\n\n        parameters:\n            dia_recentes_path (str): Caminho para o diret\u00f3rio do dia mais recente.\n\n        returns:\n            str: Caminho do arquivo mais recente de 'products',\n                 ou None se n\u00e3o encontrado.\n        \"\"\"\n        return self.buscar_arquivo_por_tipo(\n            dia_recentes_path, FileType.PRODUCTS\n        )\n\n    def buscar_users(self, dia_recentes_path):\n        \"\"\"\n        Busca o arquivo mais recente do tipo 'users' no diret\u00f3rio especificado.\n\n        parameters:\n            dia_recentes_path (str): Caminho para o diret\u00f3rio\n                                        do dia mais recente.\n\n        returns:\n            str: Caminho do arquivo mais recente de 'users',\n                 ou None se n\u00e3o encontrado.\n        \"\"\"\n        return self.buscar_arquivo_por_tipo(dia_recentes_path, FileType.USERS)\n\n    def buscar_categories(self, dia_recentes_path):\n        \"\"\"\n        Busca o arquivo mais recente do tipo 'categories' no diret\u00f3rio\n        especificado.\n\n        parameters:\n            dia_recentes_path (str): Caminho para o diret\u00f3rio\n                                     do dia mais recente.\n\n        returns:\n            str: Caminho do arquivo mais recente de\n                 'categories', ou None se n\u00e3o encontrado.\n        \"\"\"\n        return self.buscar_arquivo_por_tipo(\n            dia_recentes_path, FileType.CATEGORIES\n        )\n\n    def buscar_arquivo_por_tipo(self, dia_recentes_path, tipo):\n        \"\"\"\n        Encontra o arquivo mais recente de um tipo\n        espec\u00edfico no diret\u00f3rio fornecido.\n\n        parameters:\n            dia_recentes_path (str): Caminho para o diret\u00f3rio\n                                     do dia mais recente.\n            tipo (FileType): Tipo do arquivo a ser buscado\n            (carts, products, users, categories).\n\n        returns:\n            str: Caminho para o arquivo mais recente do\n                 tipo especificado, ou None se n\u00e3o encontrado.\n        \"\"\"\n        arquivos = [\n            arquivo\n            for arquivo in os.listdir(dia_recentes_path)\n            if arquivo.endswith(\".json\") and tipo.value in arquivo\n        ]\n\n        if not arquivos:\n            logging.warning(\n                f\"Nenhum arquivo encontrado para o tipo {tipo.value}.\"\n            )\n            return None\n\n        arquivos.sort(key=self.extraindo_data_arquivo)\n        arquivo_recente = arquivos[-1]\n        logging.info(\n            f\"Arquivo recente encontrado para {tipo.value}: {arquivo_recente}\"\n        )\n        return os.path.join(dia_recentes_path, arquivo_recente)\n\n    def obter_ano_recentes(self):\n        \"\"\"\n        Obt\u00e9m o ano mais recente no diret\u00f3rio base,\n        considerando que os subdiret\u00f3rios\n        representam os anos em formato num\u00e9rico.\n\n        parameters:\n            str: Ano mais recente como string,\n                 ou None se nenhum diret\u00f3rio de ano for encontrado.\n        \"\"\"\n        anos = [\n            d\n            for d in os.listdir(self.base_dir)\n            if os.path.isdir(os.path.join(self.base_dir, d))\n        ]\n        ano_recentes = max(anos, key=int) if anos else None\n        logging.info(f\"Ano mais recente encontrado: {ano_recentes}\")\n        return ano_recentes\n\n    def obter_mes_recentes(self, ano):\n        \"\"\"\n        Obt\u00e9m o m\u00eas mais recente para o ano fornecido no diret\u00f3rio base.\n\n        parameters:\n            ano (str): Ano para o qual o m\u00eas mais recente ser\u00e1 buscado.\n\n        returns:\n            str: M\u00eas mais recente como string,\n                 ou None se nenhum m\u00eas for encontrado.\n        \"\"\"\n        mes_dir = os.path.join(self.base_dir, ano)\n        meses = [\n            d\n            for d in os.listdir(mes_dir)\n            if os.path.isdir(os.path.join(mes_dir, d))\n        ]\n        mes_recentes = max(meses, key=int) if meses else None\n        logging.info(\n            f\"M\u00eas mais recente encontrado para o ano {ano}: {mes_recentes}\"\n        )\n        return mes_recentes\n\n    def obter_dia_recentes_path(self, ano, mes):\n        \"\"\"\n        Obt\u00e9m o caminho do dia mais recente para um dado ano e m\u00eas.\n\n        parameters:\n            ano (str): Ano do diret\u00f3rio.\n            mes (str): M\u00eas do diret\u00f3rio.\n\n        returns:\n            str: Caminho completo para o\n                 diret\u00f3rio do dia mais recente, ou None se n\u00e3o encontrado.\n        \"\"\"\n        dia_dir = os.path.join(self.base_dir, ano, mes)\n        dias = [\n            d\n            for d in os.listdir(dia_dir)\n            if os.path.isdir(os.path.join(dia_dir, d))\n        ]\n        if not dias:\n            logging.warning(\n                f\"Nenhum dia encontrado para o m\u00eas {mes} do ano {ano}.\"\n            )\n            return None\n        dia_recentes = max(dias, key=int)\n        dia_recentes_path = os.path.join(dia_dir, dia_recentes)\n        logging.info(\n            f\"\"\"Dia mais recente encontrado: {dia_recentes}\n            com caminho: {dia_recentes_path}\"\"\"\n        )\n        return dia_recentes_path\n\n    @staticmethod\n    def extraindo_data_arquivo(arquivo):\n        \"\"\"\n        Extrai e converte a data do nome do arquivo para compara\u00e7\u00e3o.\n\n        parameters:\n            arquivo (str): Nome do arquivo com data no formato '%Y%m%d%H%M%S'.\n\n        returns:\n            datetime: Objeto datetime representando a data extra\u00edda.\n        \"\"\"\n        data_str = arquivo.split(\"_\")[1].split(\".\")[0]\n        return datetime.strptime(data_str, \"%Y%m%d%H%M%S\")\n\n    @staticmethod\n    def _get_empty_results():\n        \"\"\"\n        Retorna uma tupla de resultados vazios,\n        indicando aus\u00eancia de arquivos recentes.\n\n        parameters:\n            tuple: Uma tupla com None para cada tipo de arquivo\n                   (carts, products, users, categories).\n        \"\"\"\n        return (None,) * len(FileType)\n</code></pre>"},{"location":"find_recent_data/#fake_store.find_recent_data.FindRecentData.__init__","title":"<code>__init__(base_dir)</code>","text":"<p>Inicializa a classe FindRecentData com o diret\u00f3rio base onde os dados est\u00e3o armazenados, organizado por ano, m\u00eas e dia.</p> <p>Parameters:</p> Name Type Description Default <code>base_dir</code> <code>str</code> <p>Caminho para o diret\u00f3rio base contendo os arquivos.</p> required Source code in <code>fake_store/find_recent_data.py</code> <pre><code>def __init__(self, base_dir):\n    \"\"\"\n    Inicializa a classe FindRecentData com o diret\u00f3rio base onde os dados\n    est\u00e3o armazenados, organizado por ano, m\u00eas e dia.\n\n    Parameters:\n        base_dir (str): Caminho para o diret\u00f3rio base contendo os arquivos.\n    \"\"\"\n    self.base_dir = base_dir\n    logging.info(f\"Iniciando DataIngestion com base_dir: {self.base_dir}\")\n</code></pre>"},{"location":"find_recent_data/#fake_store.find_recent_data.FindRecentData.buscar_arquivo_por_tipo","title":"<code>buscar_arquivo_por_tipo(dia_recentes_path, tipo)</code>","text":"<p>Encontra o arquivo mais recente de um tipo espec\u00edfico no diret\u00f3rio fornecido.</p> <p>Parameters:</p> Name Type Description Default <code>dia_recentes_path</code> <code>str</code> <p>Caminho para o diret\u00f3rio                      do dia mais recente.</p> required <code>tipo</code> <code>FileType</code> <p>Tipo do arquivo a ser buscado</p> required <p>Returns:</p> Name Type Description <code>str</code> <p>Caminho para o arquivo mais recente do  tipo especificado, ou None se n\u00e3o encontrado.</p> Source code in <code>fake_store/find_recent_data.py</code> <pre><code>def buscar_arquivo_por_tipo(self, dia_recentes_path, tipo):\n    \"\"\"\n    Encontra o arquivo mais recente de um tipo\n    espec\u00edfico no diret\u00f3rio fornecido.\n\n    parameters:\n        dia_recentes_path (str): Caminho para o diret\u00f3rio\n                                 do dia mais recente.\n        tipo (FileType): Tipo do arquivo a ser buscado\n        (carts, products, users, categories).\n\n    returns:\n        str: Caminho para o arquivo mais recente do\n             tipo especificado, ou None se n\u00e3o encontrado.\n    \"\"\"\n    arquivos = [\n        arquivo\n        for arquivo in os.listdir(dia_recentes_path)\n        if arquivo.endswith(\".json\") and tipo.value in arquivo\n    ]\n\n    if not arquivos:\n        logging.warning(\n            f\"Nenhum arquivo encontrado para o tipo {tipo.value}.\"\n        )\n        return None\n\n    arquivos.sort(key=self.extraindo_data_arquivo)\n    arquivo_recente = arquivos[-1]\n    logging.info(\n        f\"Arquivo recente encontrado para {tipo.value}: {arquivo_recente}\"\n    )\n    return os.path.join(dia_recentes_path, arquivo_recente)\n</code></pre>"},{"location":"find_recent_data/#fake_store.find_recent_data.FindRecentData.buscar_arquivos_recentes","title":"<code>buscar_arquivos_recentes()</code>","text":"<p>Busca os arquivos mais recentes para cada tipo de dado (carts, products, users, categories) com base na estrutura de diret\u00f3rios de ano,m\u00eas e dia.</p> <p>Returns:</p> Name Type Description <code>tuple</code> <p>Caminhos para os arquivos mais recentes de cada tipo,     ou None se n\u00e3o existirem arquivos para um tipo espec\u00edfico.</p> Source code in <code>fake_store/find_recent_data.py</code> <pre><code>def buscar_arquivos_recentes(self):\n    \"\"\"\n    Busca os arquivos mais recentes para cada tipo de dado\n    (carts, products, users, categories)\n    com base na estrutura de diret\u00f3rios de ano,m\u00eas e dia.\n\n    returns:\n        tuple: Caminhos para os arquivos mais recentes de cada tipo,\n                ou None se n\u00e3o existirem arquivos para um tipo espec\u00edfico.\n    \"\"\"\n    ano_recentes = self.obter_ano_recentes()\n    if ano_recentes is None:\n        logging.warning(\"Nenhum ano encontrado.\")\n        return self._get_empty_results()\n\n    mes_recentes = self.obter_mes_recentes(ano_recentes)\n    if mes_recentes is None:\n        logging.warning(\n            f\"Nenhum m\u00eas encontrado para o ano {ano_recentes}.\"\n        )\n        return self._get_empty_results()\n\n    dia_recentes_path = self.obter_dia_recentes_path(\n        ano_recentes, mes_recentes\n    )\n    if dia_recentes_path is None:\n        logging.warning(\n            f\"\"\"Nenhum dia encontrado para o m\u00eas\n            {mes_recentes} do ano {ano_recentes}.\"\"\"\n        )\n        return self._get_empty_results()\n\n    return (\n        self.buscar_carts(dia_recentes_path),\n        self.buscar_products(dia_recentes_path),\n        self.buscar_users(dia_recentes_path),\n        self.buscar_categories(dia_recentes_path),\n    )\n</code></pre>"},{"location":"find_recent_data/#fake_store.find_recent_data.FindRecentData.buscar_carts","title":"<code>buscar_carts(dia_recentes_path)</code>","text":"<p>Busca o arquivo mais recente do tipo 'carts' no diret\u00f3rio especificado.</p> <p>Parameters:</p> Name Type Description Default <code>dia_recentes_path</code> <code>str</code> <p>Caminho para o diret\u00f3rio                      do dia mais recente.</p> required <p>Returns:</p> Name Type Description <code>str</code> <p>Caminho do arquivo mais recente de 'carts',  ou None se n\u00e3o encontrado.</p> Source code in <code>fake_store/find_recent_data.py</code> <pre><code>def buscar_carts(self, dia_recentes_path):\n    \"\"\"\n    Busca o arquivo mais recente do tipo 'carts' no diret\u00f3rio especificado.\n\n    parameters:\n        dia_recentes_path (str): Caminho para o diret\u00f3rio\n                                 do dia mais recente.\n\n    returns:\n        str: Caminho do arquivo mais recente de 'carts',\n             ou None se n\u00e3o encontrado.\n    \"\"\"\n    return self.buscar_arquivo_por_tipo(dia_recentes_path, FileType.CARTS)\n</code></pre>"},{"location":"find_recent_data/#fake_store.find_recent_data.FindRecentData.buscar_categories","title":"<code>buscar_categories(dia_recentes_path)</code>","text":"<p>Busca o arquivo mais recente do tipo 'categories' no diret\u00f3rio especificado.</p> <p>Parameters:</p> Name Type Description Default <code>dia_recentes_path</code> <code>str</code> <p>Caminho para o diret\u00f3rio                      do dia mais recente.</p> required <p>Returns:</p> Name Type Description <code>str</code> <p>Caminho do arquivo mais recente de  'categories', ou None se n\u00e3o encontrado.</p> Source code in <code>fake_store/find_recent_data.py</code> <pre><code>def buscar_categories(self, dia_recentes_path):\n    \"\"\"\n    Busca o arquivo mais recente do tipo 'categories' no diret\u00f3rio\n    especificado.\n\n    parameters:\n        dia_recentes_path (str): Caminho para o diret\u00f3rio\n                                 do dia mais recente.\n\n    returns:\n        str: Caminho do arquivo mais recente de\n             'categories', ou None se n\u00e3o encontrado.\n    \"\"\"\n    return self.buscar_arquivo_por_tipo(\n        dia_recentes_path, FileType.CATEGORIES\n    )\n</code></pre>"},{"location":"find_recent_data/#fake_store.find_recent_data.FindRecentData.buscar_products","title":"<code>buscar_products(dia_recentes_path)</code>","text":"<p>Busca o arquivo mais recente do tipo 'products' no diret\u00f3rio especificado.</p> <p>Parameters:</p> Name Type Description Default <code>dia_recentes_path</code> <code>str</code> <p>Caminho para o diret\u00f3rio do dia mais recente.</p> required <p>Returns:</p> Name Type Description <code>str</code> <p>Caminho do arquivo mais recente de 'products',  ou None se n\u00e3o encontrado.</p> Source code in <code>fake_store/find_recent_data.py</code> <pre><code>def buscar_products(self, dia_recentes_path):\n    \"\"\"\n    Busca o arquivo mais recente do tipo 'products'\n    no diret\u00f3rio especificado.\n\n    parameters:\n        dia_recentes_path (str): Caminho para o diret\u00f3rio do dia mais recente.\n\n    returns:\n        str: Caminho do arquivo mais recente de 'products',\n             ou None se n\u00e3o encontrado.\n    \"\"\"\n    return self.buscar_arquivo_por_tipo(\n        dia_recentes_path, FileType.PRODUCTS\n    )\n</code></pre>"},{"location":"find_recent_data/#fake_store.find_recent_data.FindRecentData.buscar_users","title":"<code>buscar_users(dia_recentes_path)</code>","text":"<p>Busca o arquivo mais recente do tipo 'users' no diret\u00f3rio especificado.</p> <p>Parameters:</p> Name Type Description Default <code>dia_recentes_path</code> <code>str</code> <p>Caminho para o diret\u00f3rio                         do dia mais recente.</p> required <p>Returns:</p> Name Type Description <code>str</code> <p>Caminho do arquivo mais recente de 'users',  ou None se n\u00e3o encontrado.</p> Source code in <code>fake_store/find_recent_data.py</code> <pre><code>def buscar_users(self, dia_recentes_path):\n    \"\"\"\n    Busca o arquivo mais recente do tipo 'users' no diret\u00f3rio especificado.\n\n    parameters:\n        dia_recentes_path (str): Caminho para o diret\u00f3rio\n                                    do dia mais recente.\n\n    returns:\n        str: Caminho do arquivo mais recente de 'users',\n             ou None se n\u00e3o encontrado.\n    \"\"\"\n    return self.buscar_arquivo_por_tipo(dia_recentes_path, FileType.USERS)\n</code></pre>"},{"location":"find_recent_data/#fake_store.find_recent_data.FindRecentData.extraindo_data_arquivo","title":"<code>extraindo_data_arquivo(arquivo)</code>  <code>staticmethod</code>","text":"<p>Extrai e converte a data do nome do arquivo para compara\u00e7\u00e3o.</p> <p>Parameters:</p> Name Type Description Default <code>arquivo</code> <code>str</code> <p>Nome do arquivo com data no formato '%Y%m%d%H%M%S'.</p> required <p>Returns:</p> Name Type Description <code>datetime</code> <p>Objeto datetime representando a data extra\u00edda.</p> Source code in <code>fake_store/find_recent_data.py</code> <pre><code>@staticmethod\ndef extraindo_data_arquivo(arquivo):\n    \"\"\"\n    Extrai e converte a data do nome do arquivo para compara\u00e7\u00e3o.\n\n    parameters:\n        arquivo (str): Nome do arquivo com data no formato '%Y%m%d%H%M%S'.\n\n    returns:\n        datetime: Objeto datetime representando a data extra\u00edda.\n    \"\"\"\n    data_str = arquivo.split(\"_\")[1].split(\".\")[0]\n    return datetime.strptime(data_str, \"%Y%m%d%H%M%S\")\n</code></pre>"},{"location":"find_recent_data/#fake_store.find_recent_data.FindRecentData.obter_ano_recentes","title":"<code>obter_ano_recentes()</code>","text":"<p>Obt\u00e9m o ano mais recente no diret\u00f3rio base, considerando que os subdiret\u00f3rios representam os anos em formato num\u00e9rico.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>Ano mais recente como string,  ou None se nenhum diret\u00f3rio de ano for encontrado.</p> required Source code in <code>fake_store/find_recent_data.py</code> <pre><code>def obter_ano_recentes(self):\n    \"\"\"\n    Obt\u00e9m o ano mais recente no diret\u00f3rio base,\n    considerando que os subdiret\u00f3rios\n    representam os anos em formato num\u00e9rico.\n\n    parameters:\n        str: Ano mais recente como string,\n             ou None se nenhum diret\u00f3rio de ano for encontrado.\n    \"\"\"\n    anos = [\n        d\n        for d in os.listdir(self.base_dir)\n        if os.path.isdir(os.path.join(self.base_dir, d))\n    ]\n    ano_recentes = max(anos, key=int) if anos else None\n    logging.info(f\"Ano mais recente encontrado: {ano_recentes}\")\n    return ano_recentes\n</code></pre>"},{"location":"find_recent_data/#fake_store.find_recent_data.FindRecentData.obter_dia_recentes_path","title":"<code>obter_dia_recentes_path(ano, mes)</code>","text":"<p>Obt\u00e9m o caminho do dia mais recente para um dado ano e m\u00eas.</p> <p>Parameters:</p> Name Type Description Default <code>ano</code> <code>str</code> <p>Ano do diret\u00f3rio.</p> required <code>mes</code> <code>str</code> <p>M\u00eas do diret\u00f3rio.</p> required <p>Returns:</p> Name Type Description <code>str</code> <p>Caminho completo para o  diret\u00f3rio do dia mais recente, ou None se n\u00e3o encontrado.</p> Source code in <code>fake_store/find_recent_data.py</code> <pre><code>def obter_dia_recentes_path(self, ano, mes):\n    \"\"\"\n    Obt\u00e9m o caminho do dia mais recente para um dado ano e m\u00eas.\n\n    parameters:\n        ano (str): Ano do diret\u00f3rio.\n        mes (str): M\u00eas do diret\u00f3rio.\n\n    returns:\n        str: Caminho completo para o\n             diret\u00f3rio do dia mais recente, ou None se n\u00e3o encontrado.\n    \"\"\"\n    dia_dir = os.path.join(self.base_dir, ano, mes)\n    dias = [\n        d\n        for d in os.listdir(dia_dir)\n        if os.path.isdir(os.path.join(dia_dir, d))\n    ]\n    if not dias:\n        logging.warning(\n            f\"Nenhum dia encontrado para o m\u00eas {mes} do ano {ano}.\"\n        )\n        return None\n    dia_recentes = max(dias, key=int)\n    dia_recentes_path = os.path.join(dia_dir, dia_recentes)\n    logging.info(\n        f\"\"\"Dia mais recente encontrado: {dia_recentes}\n        com caminho: {dia_recentes_path}\"\"\"\n    )\n    return dia_recentes_path\n</code></pre>"},{"location":"find_recent_data/#fake_store.find_recent_data.FindRecentData.obter_mes_recentes","title":"<code>obter_mes_recentes(ano)</code>","text":"<p>Obt\u00e9m o m\u00eas mais recente para o ano fornecido no diret\u00f3rio base.</p> <p>Parameters:</p> Name Type Description Default <code>ano</code> <code>str</code> <p>Ano para o qual o m\u00eas mais recente ser\u00e1 buscado.</p> required <p>Returns:</p> Name Type Description <code>str</code> <p>M\u00eas mais recente como string,  ou None se nenhum m\u00eas for encontrado.</p> Source code in <code>fake_store/find_recent_data.py</code> <pre><code>def obter_mes_recentes(self, ano):\n    \"\"\"\n    Obt\u00e9m o m\u00eas mais recente para o ano fornecido no diret\u00f3rio base.\n\n    parameters:\n        ano (str): Ano para o qual o m\u00eas mais recente ser\u00e1 buscado.\n\n    returns:\n        str: M\u00eas mais recente como string,\n             ou None se nenhum m\u00eas for encontrado.\n    \"\"\"\n    mes_dir = os.path.join(self.base_dir, ano)\n    meses = [\n        d\n        for d in os.listdir(mes_dir)\n        if os.path.isdir(os.path.join(mes_dir, d))\n    ]\n    mes_recentes = max(meses, key=int) if meses else None\n    logging.info(\n        f\"M\u00eas mais recente encontrado para o ano {ano}: {mes_recentes}\"\n    )\n    return mes_recentes\n</code></pre>"},{"location":"models/","title":"Modelo de dados","text":"<p>Aqui est\u00e1 o modelo de dados usado para verifica\u00e7\u00e3o dos dados.</p>"},{"location":"models/#fake_store.models","title":"<code>fake_store.models</code>","text":""},{"location":"models/#fake_store.models.Address","title":"<code>Address</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Representa um endere\u00e7o.</p> <p>Parameters:</p> Name Type Description Default <code>city</code> <code>str</code> <p>Nome da cidade.</p> required <code>street</code> <code>str</code> <p>Nome da rua.</p> required <code>number</code> <code>int</code> <p>N\u00famero do endere\u00e7o.</p> required <code>zipcode</code> <code>str</code> <p>C\u00f3digo postal.</p> required <code>geolocation</code> <code>GeoLocation</code> <p>Localiza\u00e7\u00e3o geogr\u00e1fica do endere\u00e7o.</p> required Source code in <code>fake_store/models.py</code> <pre><code>class Address(BaseModel):\n    \"\"\"\n    Representa um endere\u00e7o.\n\n    Args:\n        city (str): Nome da cidade.\n        street (str): Nome da rua.\n        number (int): N\u00famero do endere\u00e7o.\n        zipcode (str): C\u00f3digo postal.\n        geolocation (GeoLocation): Localiza\u00e7\u00e3o geogr\u00e1fica do endere\u00e7o.\n    \"\"\"\n\n    city: str\n    street: str\n    number: int\n    zipcode: str\n    geolocation: GeoLocation\n</code></pre>"},{"location":"models/#fake_store.models.Cart","title":"<code>Cart</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Representa o carrinho de compras de um usu\u00e1rio.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>int</code> <p>Identificador \u00fanico do carrinho.</p> required <code>userId</code> <code>int</code> <p>Identificador do usu\u00e1rio que possui o carrinho.</p> required <code>date</code> <code>datetime</code> <p>Data em que o carrinho foi criado ou atualizado.</p> required <code>products</code> <code>List[ProductsInCart]</code> <p>Lista de produtos no carrinho.</p> required Source code in <code>fake_store/models.py</code> <pre><code>class Cart(BaseModel):\n    \"\"\"\n    Representa o carrinho de compras de um usu\u00e1rio.\n\n    Args:\n        id (int): Identificador \u00fanico do carrinho.\n        userId (int): Identificador do usu\u00e1rio que possui o carrinho.\n        date (datetime): Data em que o carrinho foi criado ou atualizado.\n        products (List[ProductsInCart]): Lista de produtos no carrinho.\n    \"\"\"\n\n    id: int\n    userId: int\n    date: datetime\n    products: List[ProductsInCart]\n</code></pre>"},{"location":"models/#fake_store.models.Categories","title":"<code>Categories</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Representa as categorias de produtos dispon\u00edveis.</p> <p>Parameters:</p> Name Type Description Default <code>category</code> <code>List[Literal]</code> <p>Lista de categorias v\u00e1lidas, incluindo</p> required Source code in <code>fake_store/models.py</code> <pre><code>class Categories(BaseModel):\n    \"\"\"\n    Representa as categorias de produtos dispon\u00edveis.\n\n    Args:\n        category (List[Literal]): Lista de categorias v\u00e1lidas, incluindo\n        \"electronics\", \"jewelery\", \"men's clothing\", \"women's clothing\".\n    \"\"\"\n\n    category: List[\n        Literal[\n            \"electronics\", \"jewelery\", \"men's clothing\", \"women's clothing\"\n        ]\n    ]\n</code></pre>"},{"location":"models/#fake_store.models.GeoLocation","title":"<code>GeoLocation</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Representa a localiza\u00e7\u00e3o geogr\u00e1fica.</p> <p>Parameters:</p> Name Type Description Default <code>lat</code> <code>str</code> <p>Latitude.</p> required <code>long</code> <code>str</code> <p>Longitude.</p> required Source code in <code>fake_store/models.py</code> <pre><code>class GeoLocation(BaseModel):\n    \"\"\"\n    Representa a localiza\u00e7\u00e3o geogr\u00e1fica.\n\n    Args:\n        lat (str): Latitude.\n        long (str): Longitude.\n    \"\"\"\n\n    lat: str\n    long: str\n</code></pre>"},{"location":"models/#fake_store.models.Name","title":"<code>Name</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Representa o nome de uma pessoa.</p> <p>Parameters:</p> Name Type Description Default <code>firstname</code> <code>str</code> <p>Primeiro nome.</p> required <code>lastname</code> <code>str</code> <p>Sobrenome.</p> required Source code in <code>fake_store/models.py</code> <pre><code>class Name(BaseModel):\n    \"\"\"\n    Representa o nome de uma pessoa.\n\n    Args:\n        firstname (str): Primeiro nome.\n        lastname (str): Sobrenome.\n    \"\"\"\n\n    firstname: str\n    lastname: str\n</code></pre>"},{"location":"models/#fake_store.models.Product","title":"<code>Product</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Representa um produto.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>int</code> <p>Identificador \u00fanico do produto.</p> required <code>title</code> <code>str</code> <p>T\u00edtulo do produto.</p> required <code>price</code> <code>float</code> <p>Pre\u00e7o do produto.</p> required <code>category</code> <code>Literal</code> <p>Categoria do produto, que pode ser</p> required <code>description</code> <code>str</code> <p>Descri\u00e7\u00e3o do produto.</p> required <code>image</code> <code>str</code> <p>URL da imagem do produto.</p> required Source code in <code>fake_store/models.py</code> <pre><code>class Product(BaseModel):\n    \"\"\"\n    Representa um produto.\n\n    Args:\n        id (int): Identificador \u00fanico do produto.\n        title (str): T\u00edtulo do produto.\n        price (float): Pre\u00e7o do produto.\n        category (Literal): Categoria do produto, que pode ser\n        \"electronics\", \"jewelery\", \"men's clothing\" ou \"women's clothing\".\n        description (str): Descri\u00e7\u00e3o do produto.\n        image (str): URL da imagem do produto.\n    \"\"\"\n\n    id: int\n    title: str\n    price: float\n    category: Literal[\n        \"electronics\", \"jewelery\", \"men's clothing\", \"women's clothing\"\n    ]\n    description: str\n    image: str\n</code></pre>"},{"location":"models/#fake_store.models.ProductsInCart","title":"<code>ProductsInCart</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Representa um produto que est\u00e1 no carrinho.</p> <p>Parameters:</p> Name Type Description Default <code>productId</code> <code>int</code> <p>Identificador do produto.</p> required <code>quantity</code> <code>conint</code> <p>Quantidade do produto, deve ser maior ou igual a 1.</p> required Source code in <code>fake_store/models.py</code> <pre><code>class ProductsInCart(BaseModel):\n    \"\"\"\n    Representa um produto que est\u00e1 no carrinho.\n\n    Args:\n        productId (int): Identificador do produto.\n        quantity (conint): Quantidade do produto, deve ser maior ou igual a 1.\n    \"\"\"\n\n    productId: int\n    quantity: conint(ge=1)\n</code></pre>"},{"location":"models/#fake_store.models.User","title":"<code>User</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Representa um \u00fanico usu\u00e1rio.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>int</code> <p>Identificador \u00fanico do usu\u00e1rio.</p> required <code>email</code> <code>EmailStr</code> <p>Endere\u00e7o de e-mail do usu\u00e1rio.</p> required <code>username</code> <code>str</code> <p>Nome de usu\u00e1rio.</p> required <code>password</code> <code>str</code> <p>Senha do usu\u00e1rio.</p> required <code>name</code> <code>Name</code> <p>Nome completo do usu\u00e1rio.</p> required <code>address</code> <code>Address</code> <p>Endere\u00e7o do usu\u00e1rio.</p> required <code>phone</code> <code>str</code> <p>N\u00famero de telefone do usu\u00e1rio.</p> required Source code in <code>fake_store/models.py</code> <pre><code>class User(BaseModel):\n    \"\"\"\n    Representa um \u00fanico usu\u00e1rio.\n\n    Args:\n        id (int): Identificador \u00fanico do usu\u00e1rio.\n        email (EmailStr): Endere\u00e7o de e-mail do usu\u00e1rio.\n        username (str): Nome de usu\u00e1rio.\n        password (str): Senha do usu\u00e1rio.\n        name (Name): Nome completo do usu\u00e1rio.\n        address (Address): Endere\u00e7o do usu\u00e1rio.\n        phone (str): N\u00famero de telefone do usu\u00e1rio.\n    \"\"\"\n\n    id: int\n    email: EmailStr\n    username: str\n    password: str\n    name: Name\n    address: Address\n    phone: str\n</code></pre>"},{"location":"gold/gold/","title":"Camada Gold","text":"<p>A Camada Gold representa a etapa final do nosso fluxo de dados, onde os dados extra\u00eddos da camada Silver s\u00e3o processados e organizados em uma tabela final, pronta para an\u00e1lise e relat\u00f3rios. Nesta camada, focamos em consolidar informa\u00e7\u00f5es relevantes sobre o comportamento dos usu\u00e1rios, gerando insights que podem ser utilizados para melhorar a experi\u00eancia do cliente e otimizar as opera\u00e7\u00f5es de e-commerce.</p>"},{"location":"gold/gold/#estrutura-da-tabela-final","title":"Estrutura da Tabela Final","text":"<p>A tabela final da Camada Gold cont\u00e9m os seguintes campos:</p> <ul> <li>Identificador de Usu\u00e1rio: Um identificador \u00fanico para cada usu\u00e1rio, permitindo rastrear suas atividades.</li> <li>Contagem de Produtos no Carrinho: O n\u00famero total de produtos que cada usu\u00e1rio tem em seu carrinho de compras.</li> <li>Data Mais Recente de Adi\u00e7\u00e3o ao Carrinho: A data e hora em que o usu\u00e1rio adicionou produtos pela \u00faltima vez ao carrinho.</li> <li>Categoria com Maior Quantidade de Produtos: A categoria de produtos em que o usu\u00e1rio tem a maior quantidade de itens adicionados ao carrinho, proporcionando insights sobre suas prefer\u00eancias de compra.</li> </ul> <p>Esses dados s\u00e3o organizados em um arquivo <code>.csv</code> que pode ser encontrado na pasta <code>data/marts/</code> ou acessado diretamente pelo https://fakestore.streamlit.app .</p>"},{"location":"gold/gold/#vantagens-da-camada-gold","title":"Vantagens da Camada Gold","text":"<ol> <li> <p>Acesso R\u00e1pido a Informa\u00e7\u00f5es Relevantes: A tabela Gold \u00e9 otimizada para consultas frequentes, permitindo que as partes interessadas acessem rapidamente informa\u00e7\u00f5es cr\u00edticas sobre o comportamento dos usu\u00e1rios.</p> </li> <li> <p>Suporte a An\u00e1lises Avan\u00e7adas: Os dados organizados na Camada Gold facilitam a aplica\u00e7\u00e3o de t\u00e9cnicas de an\u00e1lise, como an\u00e1lise preditiva e segmenta\u00e7\u00e3o de clientes, melhorando a tomada de decis\u00f5es estrat\u00e9gicas.</p> </li> <li> <p>Integra\u00e7\u00e3o com Ferramentas de Visualiza\u00e7\u00e3o: O arquivo <code>.csv</code> gerado pode ser facilmente importado para ferramentas de visualiza\u00e7\u00e3o de dados, como Tableau ou Power BI, possibilitando a cria\u00e7\u00e3o de dashboards e relat\u00f3rios interativos.</p> </li> </ol>"},{"location":"gold/gold/#consideracoes-finais","title":"Considera\u00e7\u00f5es Finais","text":"<p>A Camada Gold \u00e9 o culminar do nosso fluxo de dados, onde as informa\u00e7\u00f5es s\u00e3o refinadas e preparadas para an\u00e1lise. A estrutura e a organiza\u00e7\u00e3o dos dados nesta camada s\u00e3o fundamentais para permitir insights valiosos que podem impulsionar decis\u00f5es de neg\u00f3cio no e-commerce. Com o acesso facilitado aos dados, as equipes podem monitorar o desempenho e adaptar suas estrat\u00e9gias para melhor atender \u00e0s necessidades dos clientes.</p> <p>Para acessar o arquivo final, voc\u00ea pode navegar at\u00e9 a pasta <code>data/marts/</code> ou utilizar o webapp Streamlit, que fornece uma interface amig\u00e1vel para explorar os dados gerados.</p>"},{"location":"gold/gold_data_extract/","title":"Extra\u00e7\u00e3o da tabela final para csv","text":""},{"location":"gold/gold_data_extract/#fake_store.gold_data_extract","title":"<code>fake_store.gold_data_extract</code>","text":""},{"location":"gold/gold_data_extract/#fake_store.gold_data_extract.GoldDataExtract","title":"<code>GoldDataExtract</code>","text":"Source code in <code>fake_store/gold_data_extract.py</code> <pre><code>class GoldDataExtract:\n    def __init__(self, db_path):\n        \"\"\"\n        Inicializa a conex\u00e3o com o banco de dados SQLite.\n\n        parameters:\n            db_path: Caminho para o arquivo do banco de dados SQLite.\n        \"\"\"\n        self.db_path = db_path\n\n    def export_to_csv(self, table_name, csv_path):\n        \"\"\"\n        Exporta os dados de uma tabela SQLite para um arquivo CSV.\n\n        parameters:\n            table_name: Nome da tabela a ser exportada.\n            csv_path: Caminho para o arquivo CSV de sa\u00edda.\n        \"\"\"\n        output_dir = os.path.dirname(csv_path)\n        if output_dir and not os.path.exists(output_dir):\n            os.makedirs(output_dir)\n\n        conn = sqlite3.connect(self.db_path)\n        cursor = conn.cursor()\n\n        try:\n            cursor.execute(f\"SELECT * FROM {table_name}\")\n            rows = cursor.fetchall()\n\n            column_names = [\n                description[0] for description in cursor.description\n            ]\n\n            with open(\n                csv_path, mode=\"w\", newline=\"\", encoding=\"utf-8\"\n            ) as file:\n                writer = csv.writer(file)\n                writer.writerow(column_names)\n                writer.writerows(rows)\n\n            print(f\"Dados exportados com sucesso para {csv_path}\")\n\n        except sqlite3.Error as e:\n            print(f\"Erro ao exportar dados: {e}\")\n\n        finally:\n            conn.close()\n</code></pre>"},{"location":"gold/gold_data_extract/#fake_store.gold_data_extract.GoldDataExtract.__init__","title":"<code>__init__(db_path)</code>","text":"<p>Inicializa a conex\u00e3o com o banco de dados SQLite.</p> <p>Parameters:</p> Name Type Description Default <code>db_path</code> <p>Caminho para o arquivo do banco de dados SQLite.</p> required Source code in <code>fake_store/gold_data_extract.py</code> <pre><code>def __init__(self, db_path):\n    \"\"\"\n    Inicializa a conex\u00e3o com o banco de dados SQLite.\n\n    parameters:\n        db_path: Caminho para o arquivo do banco de dados SQLite.\n    \"\"\"\n    self.db_path = db_path\n</code></pre>"},{"location":"gold/gold_data_extract/#fake_store.gold_data_extract.GoldDataExtract.export_to_csv","title":"<code>export_to_csv(table_name, csv_path)</code>","text":"<p>Exporta os dados de uma tabela SQLite para um arquivo CSV.</p> <p>Parameters:</p> Name Type Description Default <code>table_name</code> <p>Nome da tabela a ser exportada.</p> required <code>csv_path</code> <p>Caminho para o arquivo CSV de sa\u00edda.</p> required Source code in <code>fake_store/gold_data_extract.py</code> <pre><code>def export_to_csv(self, table_name, csv_path):\n    \"\"\"\n    Exporta os dados de uma tabela SQLite para um arquivo CSV.\n\n    parameters:\n        table_name: Nome da tabela a ser exportada.\n        csv_path: Caminho para o arquivo CSV de sa\u00edda.\n    \"\"\"\n    output_dir = os.path.dirname(csv_path)\n    if output_dir and not os.path.exists(output_dir):\n        os.makedirs(output_dir)\n\n    conn = sqlite3.connect(self.db_path)\n    cursor = conn.cursor()\n\n    try:\n        cursor.execute(f\"SELECT * FROM {table_name}\")\n        rows = cursor.fetchall()\n\n        column_names = [\n            description[0] for description in cursor.description\n        ]\n\n        with open(\n            csv_path, mode=\"w\", newline=\"\", encoding=\"utf-8\"\n        ) as file:\n            writer = csv.writer(file)\n            writer.writerow(column_names)\n            writer.writerows(rows)\n\n        print(f\"Dados exportados com sucesso para {csv_path}\")\n\n    except sqlite3.Error as e:\n        print(f\"Erro ao exportar dados: {e}\")\n\n    finally:\n        conn.close()\n</code></pre>"},{"location":"gold/gold_database/","title":"Cria o banco de dados final","text":""},{"location":"gold/gold_database/#fake_store.gold_database","title":"<code>fake_store.gold_database</code>","text":""},{"location":"gold/gold_database/#fake_store.gold_database.GoldDatabase","title":"<code>GoldDatabase</code>","text":"<p>Gerencia a conex\u00e3o e inicializa\u00e7\u00e3o do banco de dados.</p> Source code in <code>fake_store/gold_database.py</code> <pre><code>class GoldDatabase:\n    \"\"\"\n    Gerencia a conex\u00e3o e inicializa\u00e7\u00e3o do banco de dados.\n    \"\"\"\n\n    def __init__(self, db_path=\"data/gold\", db_name=\"fake_store_gold.db\"):\n        \"\"\"\n        Inicializa o gerenciador de banco de dados.\n\n        parameters:\n            db_path (str): Caminho do diret\u00f3rio onde o arquivo do\n                           banco de dados ser\u00e1 salvo.\n            db_name (str): Nome do arquivo do banco de dados.\n        \"\"\"\n        self.db_path = db_path\n        self.db_name = db_name\n        self.conn = None\n        self.cursor = None\n\n    def connect(self):\n        \"\"\"Conecta ao banco de dados.\"\"\"\n        self.conn = sqlite3.connect(os.path.join(self.db_path, self.db_name))\n        self.cursor = self.conn.cursor()\n        logging.info(\"Conex\u00e3o estabelecida com o banco de dados.\")\n\n    def create_tables(self):\n        \"\"\"Cria as tabelas no banco de dados se ainda n\u00e3o foram criadas.\"\"\"\n        self.cursor.executescript(\n            \"\"\"\n        CREATE TABLE IF NOT EXISTS user_cart_insights (\n            user_id INTEGER PRIMARY KEY,\n            total_products INTEGER NOT NULL DEFAULT 0,\n            most_frequent_category TEXT NOT NULL DEFAULT 'sem compra',\n            most_recent_cart_date TEXT NOT NULL DEFAULT '0000-00-00 00:00:00',\n            FOREIGN KEY (user_id) REFERENCES users(id)\n        );\n\n        \"\"\"\n        )\n        self.conn.commit()\n        logging.info(\"Tabelas criadas ou j\u00e1 existem no banco de dados.\")\n\n    def initialize_database(self):\n        \"\"\"\n        Inicializa o banco de dados verificando se o arquivo j\u00e1 existe.\n        Se o arquivo n\u00e3o existir, cria as tabelas.\n        \"\"\"\n        full_db_path = os.path.join(self.db_path, self.db_name)\n        if not os.path.isfile(full_db_path):\n            logging.info(\n                f\"Criando o banco de dados {self.db_name} em {self.db_path}...\"\n            )\n            self.connect()\n            self.create_tables()\n            logging.info(\"Banco de dados criado com sucesso.\")\n        else:\n            logging.info(f\"Conectando ao banco de dados {full_db_path}.\")\n            self.connect()\n\n    def close(self):\n        \"\"\"Fecha a conex\u00e3o com o banco de dados.\"\"\"\n        if self.conn:\n            self.conn.close()\n            logging.info(\"Conex\u00e3o com o banco de dados fechada.\")\n</code></pre>"},{"location":"gold/gold_database/#fake_store.gold_database.GoldDatabase.__init__","title":"<code>__init__(db_path='data/gold', db_name='fake_store_gold.db')</code>","text":"<p>Inicializa o gerenciador de banco de dados.</p> <p>Parameters:</p> Name Type Description Default <code>db_path</code> <code>str</code> <p>Caminho do diret\u00f3rio onde o arquivo do            banco de dados ser\u00e1 salvo.</p> <code>'data/gold'</code> <code>db_name</code> <code>str</code> <p>Nome do arquivo do banco de dados.</p> <code>'fake_store_gold.db'</code> Source code in <code>fake_store/gold_database.py</code> <pre><code>def __init__(self, db_path=\"data/gold\", db_name=\"fake_store_gold.db\"):\n    \"\"\"\n    Inicializa o gerenciador de banco de dados.\n\n    parameters:\n        db_path (str): Caminho do diret\u00f3rio onde o arquivo do\n                       banco de dados ser\u00e1 salvo.\n        db_name (str): Nome do arquivo do banco de dados.\n    \"\"\"\n    self.db_path = db_path\n    self.db_name = db_name\n    self.conn = None\n    self.cursor = None\n</code></pre>"},{"location":"gold/gold_database/#fake_store.gold_database.GoldDatabase.close","title":"<code>close()</code>","text":"<p>Fecha a conex\u00e3o com o banco de dados.</p> Source code in <code>fake_store/gold_database.py</code> <pre><code>def close(self):\n    \"\"\"Fecha a conex\u00e3o com o banco de dados.\"\"\"\n    if self.conn:\n        self.conn.close()\n        logging.info(\"Conex\u00e3o com o banco de dados fechada.\")\n</code></pre>"},{"location":"gold/gold_database/#fake_store.gold_database.GoldDatabase.connect","title":"<code>connect()</code>","text":"<p>Conecta ao banco de dados.</p> Source code in <code>fake_store/gold_database.py</code> <pre><code>def connect(self):\n    \"\"\"Conecta ao banco de dados.\"\"\"\n    self.conn = sqlite3.connect(os.path.join(self.db_path, self.db_name))\n    self.cursor = self.conn.cursor()\n    logging.info(\"Conex\u00e3o estabelecida com o banco de dados.\")\n</code></pre>"},{"location":"gold/gold_database/#fake_store.gold_database.GoldDatabase.create_tables","title":"<code>create_tables()</code>","text":"<p>Cria as tabelas no banco de dados se ainda n\u00e3o foram criadas.</p> Source code in <code>fake_store/gold_database.py</code> <pre><code>def create_tables(self):\n    \"\"\"Cria as tabelas no banco de dados se ainda n\u00e3o foram criadas.\"\"\"\n    self.cursor.executescript(\n        \"\"\"\n    CREATE TABLE IF NOT EXISTS user_cart_insights (\n        user_id INTEGER PRIMARY KEY,\n        total_products INTEGER NOT NULL DEFAULT 0,\n        most_frequent_category TEXT NOT NULL DEFAULT 'sem compra',\n        most_recent_cart_date TEXT NOT NULL DEFAULT '0000-00-00 00:00:00',\n        FOREIGN KEY (user_id) REFERENCES users(id)\n    );\n\n    \"\"\"\n    )\n    self.conn.commit()\n    logging.info(\"Tabelas criadas ou j\u00e1 existem no banco de dados.\")\n</code></pre>"},{"location":"gold/gold_database/#fake_store.gold_database.GoldDatabase.initialize_database","title":"<code>initialize_database()</code>","text":"<p>Inicializa o banco de dados verificando se o arquivo j\u00e1 existe. Se o arquivo n\u00e3o existir, cria as tabelas.</p> Source code in <code>fake_store/gold_database.py</code> <pre><code>def initialize_database(self):\n    \"\"\"\n    Inicializa o banco de dados verificando se o arquivo j\u00e1 existe.\n    Se o arquivo n\u00e3o existir, cria as tabelas.\n    \"\"\"\n    full_db_path = os.path.join(self.db_path, self.db_name)\n    if not os.path.isfile(full_db_path):\n        logging.info(\n            f\"Criando o banco de dados {self.db_name} em {self.db_path}...\"\n        )\n        self.connect()\n        self.create_tables()\n        logging.info(\"Banco de dados criado com sucesso.\")\n    else:\n        logging.info(f\"Conectando ao banco de dados {full_db_path}.\")\n        self.connect()\n</code></pre>"},{"location":"gold/gold_insights_ingestion/","title":"Insere dados na tabela final do banco","text":""},{"location":"gold/gold_insights_ingestion/#fake_store.gold_insights_ingestion","title":"<code>fake_store.gold_insights_ingestion</code>","text":""},{"location":"gold/gold_insights_ingestion/#fake_store.gold_insights_ingestion.GoldDataInserter","title":"<code>GoldDataInserter</code>","text":"Source code in <code>fake_store/gold_insights_ingestion.py</code> <pre><code>class GoldDataInserter:\n    def __init__(self, silver_db: str, gold_db: str):\n        \"\"\"\n        Inicializa a classe GoldDataInserter.\n\n        parameters:\n            silver_db: Caminho para o banco de dados silver.\n            gold_db: Caminho para o banco de dados gold.\n        \"\"\"\n        self.silver_db = silver_db\n        self.gold_db = gold_db\n        self._create_gold_database()\n\n    def _create_gold_database(self):\n        \"\"\"Cria o banco de dados gold se n\u00e3o existir.\"\"\"\n        if not os.path.exists(self.gold_db):\n            logging.info(f\"Criando o banco de dados: {self.gold_db}\")\n            conn = sqlite3.connect(self.gold_db)\n            conn.close()\n\n    def _connect_silver(self):\n        \"\"\"Estabelece uma conex\u00e3o com o banco de dados silver.\"\"\"\n        return sqlite3.connect(self.silver_db)\n\n    def _connect_gold(self):\n        \"\"\"Estabelece uma conex\u00e3o com o banco de dados gold.\"\"\"\n        return sqlite3.connect(self.gold_db)\n\n    def insert_user_cart_insights(self):\n        \"\"\"\n        Insere ou atualiza os insights do carrinho de compras dos usu\u00e1rios\n        no banco de dados gold a partir do banco de dados silver.\n        \"\"\"\n        with (\n            self._connect_silver() as silver_conn,\n            self._connect_gold() as gold_conn,\n        ):\n            silver_cursor = silver_conn.cursor()\n            gold_cursor = gold_conn.cursor()\n\n            user_insights_query = \"\"\"\n            SELECT\n                u.id AS user_id,\n                COALESCE(COUNT(cp.product_id), 0) AS total_products,\n                COALESCE(c.name, 'sem compra') AS most_frequent_category,\n                COALESCE(MAX(ca.date), '0000-00-00 00:00:00')\n                    AS most_recent_cart_date\n            FROM users u\n            LEFT JOIN carts ca ON u.id = ca.user_id\n            LEFT JOIN cart_products cp ON ca.id = cp.cart_id\n            LEFT JOIN products p ON cp.product_id = p.id\n            LEFT JOIN categories c ON p.category_id = c.id\n            GROUP BY u.id\n            ORDER BY u.id;\n            \"\"\"\n\n            silver_cursor.execute(user_insights_query)\n            user_insights = silver_cursor.fetchall()\n\n            insert_query = \"\"\"\n            INSERT INTO user_cart_insights\n            (user_id, total_products, most_frequent_category,\n            most_recent_cart_date)\n            VALUES (?, ?, ?, ?)\n            ON CONFLICT(user_id) DO UPDATE SET\n                total_products = excluded.total_products,\n                most_frequent_category = excluded.most_frequent_category,\n                most_recent_cart_date = excluded.most_recent_cart_date;\n            \"\"\"\n\n            gold_cursor.executemany(insert_query, user_insights)\n            gold_conn.commit()\n            logging.info(\"Dados de user_cart_insights inseridos com sucesso.\")\n</code></pre>"},{"location":"gold/gold_insights_ingestion/#fake_store.gold_insights_ingestion.GoldDataInserter.__init__","title":"<code>__init__(silver_db, gold_db)</code>","text":"<p>Inicializa a classe GoldDataInserter.</p> <p>Parameters:</p> Name Type Description Default <code>silver_db</code> <code>str</code> <p>Caminho para o banco de dados silver.</p> required <code>gold_db</code> <code>str</code> <p>Caminho para o banco de dados gold.</p> required Source code in <code>fake_store/gold_insights_ingestion.py</code> <pre><code>def __init__(self, silver_db: str, gold_db: str):\n    \"\"\"\n    Inicializa a classe GoldDataInserter.\n\n    parameters:\n        silver_db: Caminho para o banco de dados silver.\n        gold_db: Caminho para o banco de dados gold.\n    \"\"\"\n    self.silver_db = silver_db\n    self.gold_db = gold_db\n    self._create_gold_database()\n</code></pre>"},{"location":"gold/gold_insights_ingestion/#fake_store.gold_insights_ingestion.GoldDataInserter.insert_user_cart_insights","title":"<code>insert_user_cart_insights()</code>","text":"<p>Insere ou atualiza os insights do carrinho de compras dos usu\u00e1rios no banco de dados gold a partir do banco de dados silver.</p> Source code in <code>fake_store/gold_insights_ingestion.py</code> <pre><code>def insert_user_cart_insights(self):\n    \"\"\"\n    Insere ou atualiza os insights do carrinho de compras dos usu\u00e1rios\n    no banco de dados gold a partir do banco de dados silver.\n    \"\"\"\n    with (\n        self._connect_silver() as silver_conn,\n        self._connect_gold() as gold_conn,\n    ):\n        silver_cursor = silver_conn.cursor()\n        gold_cursor = gold_conn.cursor()\n\n        user_insights_query = \"\"\"\n        SELECT\n            u.id AS user_id,\n            COALESCE(COUNT(cp.product_id), 0) AS total_products,\n            COALESCE(c.name, 'sem compra') AS most_frequent_category,\n            COALESCE(MAX(ca.date), '0000-00-00 00:00:00')\n                AS most_recent_cart_date\n        FROM users u\n        LEFT JOIN carts ca ON u.id = ca.user_id\n        LEFT JOIN cart_products cp ON ca.id = cp.cart_id\n        LEFT JOIN products p ON cp.product_id = p.id\n        LEFT JOIN categories c ON p.category_id = c.id\n        GROUP BY u.id\n        ORDER BY u.id;\n        \"\"\"\n\n        silver_cursor.execute(user_insights_query)\n        user_insights = silver_cursor.fetchall()\n\n        insert_query = \"\"\"\n        INSERT INTO user_cart_insights\n        (user_id, total_products, most_frequent_category,\n        most_recent_cart_date)\n        VALUES (?, ?, ?, ?)\n        ON CONFLICT(user_id) DO UPDATE SET\n            total_products = excluded.total_products,\n            most_frequent_category = excluded.most_frequent_category,\n            most_recent_cart_date = excluded.most_recent_cart_date;\n        \"\"\"\n\n        gold_cursor.executemany(insert_query, user_insights)\n        gold_conn.commit()\n        logging.info(\"Dados de user_cart_insights inseridos com sucesso.\")\n</code></pre>"},{"location":"raw/raw/","title":"Extra\u00e7\u00e3o de Dados para a \"Camada raw\"","text":"<p>A primeira etapa \u00e9 a extra\u00e7\u00e3o dos dados da Fake Store API. Os dados s\u00e3o salvos no formato original fornecido pela API (<code>.json</code>), em uma estrutura de arquivos local que simula uma \"camada raw\" em uma arquitetura de dados. Cada extra\u00e7\u00e3o di\u00e1ria gera novos arquivos organizados por data, possibilitando um controle de vers\u00e3o dos dados extra\u00eddos:</p> <pre><code>raw_data/\n\u2514\u2500\u2500 2024/\n    \u2514\u2500\u2500 10/\n        \u2514\u2500\u2500 30/\n            \u251c\u2500\u2500 carts_20241030161720.json\n            \u251c\u2500\u2500 products_20241030161706.json\n            \u251c\u2500\u2500 users_20241030161714.json\n</code></pre>"},{"location":"raw/raw/#vantagens-deste-metodo","title":"Vantagens deste M\u00e9todo","text":"<ol> <li> <p>Rastreamento de Hist\u00f3rico: A organiza\u00e7\u00e3o por data permite manter um hist\u00f3rico detalhado de extra\u00e7\u00f5es, facilitando auditorias e an\u00e1lises temporais, essenciais para entender tend\u00eancias e identificar mudan\u00e7as no comportamento do usu\u00e1rio.</p> </li> <li> <p>Preserva\u00e7\u00e3o do Estado Original: Manter os dados no formato <code>.json</code>, como extra\u00eddo, preserva o estado original da informa\u00e7\u00e3o. Isso permite an\u00e1lise hist\u00f3rica mesmo que a API mude, sem perda de estrutura dos dados.</p> </li> <li> <p>Disponibilidade de Dados Brutos: A camada raw serve como uma fonte fiel de dados brutos que pode ser processada novamente, garantindo uma camada inicial de persist\u00eancia sem transforma\u00e7\u00f5es.</p> </li> </ol>"},{"location":"raw/raw/#por-que-utilizar-o-formato-json","title":"Por que Utilizar o Formato <code>.json</code>","text":"<p>O <code>.json</code> \u00e9 flex\u00edvel, amplamente suportado e permite o armazenamento de dados estruturados (objetos aninhados, listas) de forma clara, facilitando o uso em ferramentas de processamento de dados e linguagens de programa\u00e7\u00e3o.</p>"},{"location":"raw/raw/#melhorias-para-cenarios-de-grande-porte","title":"Melhorias para Cen\u00e1rios de Grande Porte","text":"<p>Para um e-commerce de grande porte que coleta dados diariamente, o <code>.json</code> pode se tornar ineficiente a longo prazo devido ao armazenamento pesado e baixa efici\u00eancia em consultas. Em vez disso, recomenda-se o uso de um formato colunar, como Parquet ou ORC, que oferecem compress\u00e3o nativa e s\u00e3o otimizados para grandes volumes de dados.</p>"},{"location":"raw/raw/#recomendacoes-para-escalabilidade-e-eficiencia","title":"Recomenda\u00e7\u00f5es para Escalabilidade e Efici\u00eancia","text":"<ol> <li> <p>Agrupamento Peri\u00f3dico: Consolidar dados em intervalos maiores, como semanal ou mensalmente, simplifica a organiza\u00e7\u00e3o e reduz o n\u00famero de arquivos.</p> </li> <li> <p>Uso de Formatos Colunares: Formatos como Parquet ou ORC s\u00e3o ideais para armazenar grandes volumes de dados, melhorando a performance de leitura e reduzindo os custos de armazenamento.</p> </li> <li> <p>**Data Lakes: Utilizar data lakes (ex: AWS S3, Google Cloud Storage) permite o armazenamento incremental e particionado dos dados, melhorando a escalabilidade e a velocidade das consultas.</p> </li> </ol>"},{"location":"raw/raw/#vantagens-dos-formatos-colunares","title":"Vantagens dos Formatos Colunares","text":"<ul> <li>Economia de Armazenamento: Parquet e ORC comprimem dados de forma nativa, otimizando o espa\u00e7o em disco.</li> <li>Consultas Mais R\u00e1pidas: Esses formatos s\u00e3o otimizados para consultas em colunas espec\u00edficas, acelerando o processamento e reduzindo a quantidade de dados lida.</li> <li>Integra\u00e7\u00e3o com Ferramentas de Big Data: Amplamente compat\u00edveis com plataformas como Spark, Hive , Bigquery e Redshift, esses formatos permitem an\u00e1lises avan\u00e7adas e escal\u00e1veis.</li> </ul> <p>Essas adapta\u00e7\u00f5es tornam o fluxo de dados mais eficiente, escal\u00e1vel e sustent\u00e1vel para atender as demandas de um e-commerce de grande porte.</p>"},{"location":"silver/silver/","title":"Camada Silver","text":"<p>Depois que os dados s\u00e3o extra\u00eddos e salvos em <code>.json</code> na camada raw, o pr\u00f3ximo passo \u00e9 transformar esses dados para que possam ser armazenados de forma estruturada em um banco de dados na camada Silver.</p> <p>Nesta etapa, os arquivos <code>.json</code> s\u00e3o processados e convertidos em tabelas, utilizando um banco de dados SQLite. O SQLite foi escolhido por ser uma solu\u00e7\u00e3o simples e eficiente para uso local. No entanto, para projetos de grande porte, onde h\u00e1 necessidade de alta escalabilidade, \u00e9 recomend\u00e1vel optar por data warehouses robustos como o BigQuery ou Amazon Redshift.</p>"},{"location":"silver/silver/#motivacao-para-utilizar-a-camada-silver","title":"Motiva\u00e7\u00e3o para Utilizar a Camada Silver","text":"<p>A camada Silver \u00e9 onde ocorre a organiza\u00e7\u00e3o e estrutura\u00e7\u00e3o dos dados extra\u00eddos, com o objetivo de facilitar o acesso e a an\u00e1lise. Na pr\u00e1tica, isso significa converter os dados brutos em um formato relacional, que pode ser consultado com maior efici\u00eancia. A camada Silver representa uma etapa intermedi\u00e1ria entre os dados brutos (raw) e os dados refinados (gold), permitindo que transforma\u00e7\u00f5es e valida\u00e7\u00f5es b\u00e1sicas sejam aplicadas, como:</p> <ul> <li>Normaliza\u00e7\u00e3o: Estrutura\u00e7\u00e3o dos dados em tabelas relacionadas (ex.: usu\u00e1rios, produtos, e carrinhos) que facilitam consultas e an\u00e1lises.</li> <li>Limpeza: Remo\u00e7\u00e3o de dados duplicados, inconsistentes ou irrelevantes para o prop\u00f3sito da an\u00e1lise.</li> <li>Valida\u00e7\u00e3o: Verifica\u00e7\u00e3o da integridade dos dados para garantir consist\u00eancia e conformidade com o schema definido.</li> </ul> <p> </p>"},{"location":"silver/silver/#vantagens-do-sqlite-para-a-camada-silver","title":"Vantagens do SQLite para a Camada Silver","text":"<ol> <li> <p>Facilidade de Configura\u00e7\u00e3o: O SQLite \u00e9 um banco de dados leve e f\u00e1cil de configurar localmente, tornando-o adequado para ambientes de desenvolvimento e testes iniciais.</p> </li> <li> <p>Desempenho Razo\u00e1vel para Dados Pequenos a M\u00e9dios: Para volumes moderados de dados, o SQLite oferece um desempenho satisfat\u00f3rio para leitura e escrita, sem a necessidade de um servidor de banco de dados.</p> </li> <li> <p>Portabilidade: Como o SQLite armazena os dados em um \u00fanico arquivo, ele pode ser facilmente movido e compartilhado entre diferentes ambientes.</p> </li> </ol>"},{"location":"silver/silver/#consideracoes-para-projetos-maiores","title":"Considera\u00e7\u00f5es para Projetos Maiores","text":"<p>Para um cen\u00e1rio de produ\u00e7\u00e3o em larga escala, com um grande volume de dados e altas exig\u00eancias de processamento, a escolha do banco de dados precisa considerar solu\u00e7\u00f5es mais robustas:</p> <ul> <li>BigQuery e Amazon Redshift: S\u00e3o data warehouses otimizados para armazenar grandes volumes de dados e executar consultas complexas com alta performance. Eles suportam processamento paralelo e escal\u00e1vel, atendendo as necessidades de projetos de grande porte.</li> <li>Escalabilidade e Armazenamento: Diferente do SQLite, que \u00e9 limitado para dados locais, esses data warehouses permitem o armazenamento em nuvem, possibilitando uma expans\u00e3o conforme a demanda.</li> <li>Consultas Avan\u00e7adas e An\u00e1lise: BigQuery e Redshift s\u00e3o otimizados para an\u00e1lise de dados em larga escala, com suporte para SQL avan\u00e7ado e integra\u00e7\u00e3o com ferramentas de BI e visualiza\u00e7\u00e3o.</li> </ul>"},{"location":"silver/silver/#em-resumo","title":"Em Resumo","text":"<p>A camada Silver utiliza o SQLite para fornecer uma solu\u00e7\u00e3o pr\u00e1tica e de baixo custo para desenvolvimento e testes iniciais. Em um ambiente de produ\u00e7\u00e3o, recomenda-se a migra\u00e7\u00e3o para uma solu\u00e7\u00e3o de data warehouse que ofere\u00e7a escalabilidade, seguran\u00e7a e suporte a grandes volumes de dados, atendendo as necessidades de um projeto em larga escala.</p>"},{"location":"silver/silver_cart_ingestion/","title":"Ingest\u00e3o dos dados de Carrinhos","text":""},{"location":"silver/silver_cart_ingestion/#fake_store.silver_carts_ingestion","title":"<code>fake_store.silver_carts_ingestion</code>","text":""},{"location":"silver/silver_cart_ingestion/#fake_store.silver_carts_ingestion.CartIngestion","title":"<code>CartIngestion</code>","text":"<p>Classe para ingerir dados de carrinhos de compras em um banco SQLite.</p> Source code in <code>fake_store/silver_carts_ingestion.py</code> <pre><code>class CartIngestion:\n    \"\"\"Classe para ingerir dados de carrinhos de compras em um banco SQLite.\"\"\"\n\n    def __init__(self, db_path, json_path):\n        \"\"\"Inicializa a classe com o caminho do banco e do arquivo JSON.\n\n        Args:\n            db_path (str): Caminho do banco de dados SQLite.\n            json_path (str): Caminho do arquivo JSON com dados de carrinhos.\n        \"\"\"\n        self.db_path = db_path\n        self.json_path = json_path\n\n    def load_data(self):\n        \"\"\"Carrega dados do arquivo JSON.\"\"\"\n        try:\n            with open(self.json_path, \"r\", encoding=\"utf-8\") as file:\n                self.carts_data = json.load(file)\n            logging.info(\"Dados dos carrinhos carregados com sucesso.\")\n        except FileNotFoundError:\n            logging.error(f\"Arquivo JSON n\u00e3o encontrado: {self.json_path}\")\n            self.carts_data = []\n        except json.JSONDecodeError as e:\n            logging.error(f\"Erro ao decodificar JSON: {e}\")\n            self.carts_data = []\n\n    @classmethod\n    def insert_cart(cls, cursor, cart_data):\n        \"\"\"Insere um carrinho no banco de dados, ignorando se j\u00e1 existir.\n\n        Args:\n            cursor (sqlite3.Cursor): Cursor da conex\u00e3o SQLite.\n            cart_data (dict): Dados do carrinho a ser inserido.\n\n        Returns:\n            int: ID do carrinho inserido ou existente.\n        \"\"\"\n        cursor.execute(\n            \"INSERT OR IGNORE INTO carts (id, user_id, date) VALUES (?, ?, ?)\",\n            (cart_data[\"id\"], cart_data[\"userId\"], cart_data[\"date\"]),\n        )\n        logging.info(f\"Carrinho {cart_data['id']} inserido ou j\u00e1 existente.\")\n        return cart_data[\"id\"]\n\n    @classmethod\n    def insert_cart_product(cls, cursor, cart_id, product_data):\n        \"\"\"Insere um produto associado a um carrinho no banco de dados.\n\n        Args:\n            cursor (sqlite3.Cursor): Cursor da conex\u00e3o SQLite.\n            cart_id (int): ID do carrinho ao qual o produto pertence.\n            product_data (dict): Dados do produto a ser inserido.\n        \"\"\"\n        cursor.execute(\n            \"INSERT OR IGNORE INTO cart_products\"\n            \"(cart_id, product_id, quantity) \"\n            \"VALUES (?, ?, ?)\",\n            (cart_id, product_data[\"productId\"], product_data[\"quantity\"]),\n        )\n        logging.info(\n            f\"\"\"Produto {product_data[\"productId\"]}\n                inserido no carrinho {cart_id}.\"\"\"\n        )\n\n    def ingest_data(self):\n        \"\"\"Injeta os dados dos carrinhos no banco de dados.\"\"\"\n        self.load_data()\n\n        # Usar gerenciador de contexto para a conex\u00e3o\n        with sqlite3.connect(self.db_path) as connection:\n            cursor = connection.cursor()\n            try:\n                for cart in self.carts_data:\n                    # Inserindo o carrinho\n                    cart_date = format_date(cart[\"date\"])\n                    cart_id = self.insert_cart(\n                        cursor,\n                        {\n                            \"id\": cart[\"id\"],\n                            \"userId\": cart[\"userId\"],\n                            \"date\": cart_date,\n                        },\n                    )\n\n                    # Inserindo os produtos relacionados ao carrinho\n                    for product in cart[\"products\"]:\n                        self.insert_cart_product(cursor, cart_id, product)\n\n                logging.info(\"Todos os dados dos carrinhos foram processados.\")\n            except sqlite3.Error as e:\n                logging.error(\"Erro ao inserir dados no banco de dados: %s\", e)\n</code></pre>"},{"location":"silver/silver_cart_ingestion/#fake_store.silver_carts_ingestion.CartIngestion.__init__","title":"<code>__init__(db_path, json_path)</code>","text":"<p>Inicializa a classe com o caminho do banco e do arquivo JSON.</p> <p>Parameters:</p> Name Type Description Default <code>db_path</code> <code>str</code> <p>Caminho do banco de dados SQLite.</p> required <code>json_path</code> <code>str</code> <p>Caminho do arquivo JSON com dados de carrinhos.</p> required Source code in <code>fake_store/silver_carts_ingestion.py</code> <pre><code>def __init__(self, db_path, json_path):\n    \"\"\"Inicializa a classe com o caminho do banco e do arquivo JSON.\n\n    Args:\n        db_path (str): Caminho do banco de dados SQLite.\n        json_path (str): Caminho do arquivo JSON com dados de carrinhos.\n    \"\"\"\n    self.db_path = db_path\n    self.json_path = json_path\n</code></pre>"},{"location":"silver/silver_cart_ingestion/#fake_store.silver_carts_ingestion.CartIngestion.ingest_data","title":"<code>ingest_data()</code>","text":"<p>Injeta os dados dos carrinhos no banco de dados.</p> Source code in <code>fake_store/silver_carts_ingestion.py</code> <pre><code>def ingest_data(self):\n    \"\"\"Injeta os dados dos carrinhos no banco de dados.\"\"\"\n    self.load_data()\n\n    # Usar gerenciador de contexto para a conex\u00e3o\n    with sqlite3.connect(self.db_path) as connection:\n        cursor = connection.cursor()\n        try:\n            for cart in self.carts_data:\n                # Inserindo o carrinho\n                cart_date = format_date(cart[\"date\"])\n                cart_id = self.insert_cart(\n                    cursor,\n                    {\n                        \"id\": cart[\"id\"],\n                        \"userId\": cart[\"userId\"],\n                        \"date\": cart_date,\n                    },\n                )\n\n                # Inserindo os produtos relacionados ao carrinho\n                for product in cart[\"products\"]:\n                    self.insert_cart_product(cursor, cart_id, product)\n\n            logging.info(\"Todos os dados dos carrinhos foram processados.\")\n        except sqlite3.Error as e:\n            logging.error(\"Erro ao inserir dados no banco de dados: %s\", e)\n</code></pre>"},{"location":"silver/silver_cart_ingestion/#fake_store.silver_carts_ingestion.CartIngestion.insert_cart","title":"<code>insert_cart(cursor, cart_data)</code>  <code>classmethod</code>","text":"<p>Insere um carrinho no banco de dados, ignorando se j\u00e1 existir.</p> <p>Parameters:</p> Name Type Description Default <code>cursor</code> <code>Cursor</code> <p>Cursor da conex\u00e3o SQLite.</p> required <code>cart_data</code> <code>dict</code> <p>Dados do carrinho a ser inserido.</p> required <p>Returns:</p> Name Type Description <code>int</code> <p>ID do carrinho inserido ou existente.</p> Source code in <code>fake_store/silver_carts_ingestion.py</code> <pre><code>@classmethod\ndef insert_cart(cls, cursor, cart_data):\n    \"\"\"Insere um carrinho no banco de dados, ignorando se j\u00e1 existir.\n\n    Args:\n        cursor (sqlite3.Cursor): Cursor da conex\u00e3o SQLite.\n        cart_data (dict): Dados do carrinho a ser inserido.\n\n    Returns:\n        int: ID do carrinho inserido ou existente.\n    \"\"\"\n    cursor.execute(\n        \"INSERT OR IGNORE INTO carts (id, user_id, date) VALUES (?, ?, ?)\",\n        (cart_data[\"id\"], cart_data[\"userId\"], cart_data[\"date\"]),\n    )\n    logging.info(f\"Carrinho {cart_data['id']} inserido ou j\u00e1 existente.\")\n    return cart_data[\"id\"]\n</code></pre>"},{"location":"silver/silver_cart_ingestion/#fake_store.silver_carts_ingestion.CartIngestion.insert_cart_product","title":"<code>insert_cart_product(cursor, cart_id, product_data)</code>  <code>classmethod</code>","text":"<p>Insere um produto associado a um carrinho no banco de dados.</p> <p>Parameters:</p> Name Type Description Default <code>cursor</code> <code>Cursor</code> <p>Cursor da conex\u00e3o SQLite.</p> required <code>cart_id</code> <code>int</code> <p>ID do carrinho ao qual o produto pertence.</p> required <code>product_data</code> <code>dict</code> <p>Dados do produto a ser inserido.</p> required Source code in <code>fake_store/silver_carts_ingestion.py</code> <pre><code>@classmethod\ndef insert_cart_product(cls, cursor, cart_id, product_data):\n    \"\"\"Insere um produto associado a um carrinho no banco de dados.\n\n    Args:\n        cursor (sqlite3.Cursor): Cursor da conex\u00e3o SQLite.\n        cart_id (int): ID do carrinho ao qual o produto pertence.\n        product_data (dict): Dados do produto a ser inserido.\n    \"\"\"\n    cursor.execute(\n        \"INSERT OR IGNORE INTO cart_products\"\n        \"(cart_id, product_id, quantity) \"\n        \"VALUES (?, ?, ?)\",\n        (cart_id, product_data[\"productId\"], product_data[\"quantity\"]),\n    )\n    logging.info(\n        f\"\"\"Produto {product_data[\"productId\"]}\n            inserido no carrinho {cart_id}.\"\"\"\n    )\n</code></pre>"},{"location":"silver/silver_cart_ingestion/#fake_store.silver_carts_ingestion.CartIngestion.load_data","title":"<code>load_data()</code>","text":"<p>Carrega dados do arquivo JSON.</p> Source code in <code>fake_store/silver_carts_ingestion.py</code> <pre><code>def load_data(self):\n    \"\"\"Carrega dados do arquivo JSON.\"\"\"\n    try:\n        with open(self.json_path, \"r\", encoding=\"utf-8\") as file:\n            self.carts_data = json.load(file)\n        logging.info(\"Dados dos carrinhos carregados com sucesso.\")\n    except FileNotFoundError:\n        logging.error(f\"Arquivo JSON n\u00e3o encontrado: {self.json_path}\")\n        self.carts_data = []\n    except json.JSONDecodeError as e:\n        logging.error(f\"Erro ao decodificar JSON: {e}\")\n        self.carts_data = []\n</code></pre>"},{"location":"silver/silver_cart_ingestion/#fake_store.silver_carts_ingestion.format_date","title":"<code>format_date(date_str)</code>","text":"<p>Formata a string de data para o formato compat\u00edvel com o banco.</p> <p>Parameters:</p> Name Type Description Default <code>date_str</code> <code>str</code> <p>String de data em formato ISO.</p> required <p>Returns:</p> Name Type Description <code>str</code> <p>Data formatada no formato 'YYYY-MM-DD HH:MM:SS'.</p> Source code in <code>fake_store/silver_carts_ingestion.py</code> <pre><code>def format_date(date_str):\n    \"\"\"Formata a string de data para o formato compat\u00edvel com o banco.\n\n    Args:\n        date_str (str): String de data em formato ISO.\n\n    Returns:\n        str: Data formatada no formato 'YYYY-MM-DD HH:MM:SS'.\n    \"\"\"\n    return datetime.fromisoformat(date_str).strftime(\"%Y-%m-%d %H:%M:%S\")\n</code></pre>"},{"location":"silver/silver_category_ingestion/","title":"Ingest\u00e3o de dados de categoria dos produtos","text":""},{"location":"silver/silver_category_ingestion/#fake_store.silver_categories_ingestion","title":"<code>fake_store.silver_categories_ingestion</code>","text":""},{"location":"silver/silver_category_ingestion/#fake_store.silver_categories_ingestion.CategoryIngestion","title":"<code>CategoryIngestion</code>","text":"Source code in <code>fake_store/silver_categories_ingestion.py</code> <pre><code>class CategoryIngestion:\n    def __init__(self, db_path: str, json_path: str):\n        \"\"\"\n        Inicializa a conex\u00e3o com o banco de dados e o caminho do arquivo JSON.\n        :param db_path: Caminho do banco de dados SQLite.\n        :param json_path: Caminho do arquivo JSON com as categorias.\n        \"\"\"\n        self.db_path = db_path\n        self.json_path = json_path\n\n    def _connect_db(self):\n        \"\"\"Estabelece a conex\u00e3o com o banco de dados.\"\"\"\n        try:\n            conn = sqlite3.connect(self.db_path)\n            logging.info(\"Conex\u00e3o com o banco de dados estabelecida.\")\n            return conn\n        except sqlite3.Error as e:\n            logging.error(f\"Erro ao conectar ao banco de dados: {e}\")\n            return None\n\n    def load_json(self):\n        \"\"\"Carrega as categorias do arquivo JSON.\"\"\"\n        try:\n            with open(self.json_path, \"r\", encoding=\"utf-8\") as file:\n                data = json.load(file)\n\n            logging.info(\"Conte\u00fado do JSON carregado com sucesso.\")\n            if isinstance(data, list) and data:\n                # Verifica se a primeira entrada cont\u00e9m a chave 'category'\n                if \"category\" in data[0]:\n                    return data[0][\"category\"]\n                else:\n                    logging.warning(\n                        \"A chave 'category' n\u00e3o encontrada na entrada JSON.\"\n                    )\n            else:\n                logging.warning(\n                    \"O JSON n\u00e3o cont\u00e9m uma lista v\u00e1lida ou est\u00e1 vazio.\"\n                )\n                return []\n\n        except json.JSONDecodeError as e:\n            logging.error(f\"Erro ao decodificar o JSON: {e}\")\n            return []\n        except FileNotFoundError:\n            logging.error(f\"Arquivo JSON n\u00e3o encontrado: {self.json_path}\")\n            return []\n\n    def insert_categories(self):\n        \"\"\"Insere as categorias na tabela `categories`.\"\"\"\n        categories = self.load_json()\n\n        if not categories:\n            logging.warning(\"Nenhuma categoria encontrada para inser\u00e7\u00e3o.\")\n            return\n\n        conn = self._connect_db()\n        if conn is None:\n            logging.error(\n                \"Conex\u00e3o com o banco de dados n\u00e3o estabelecida.\"\n                // \"Abortando inser\u00e7\u00e3o.\"\n            )\n            return\n\n        cursor = conn.cursor()\n\n        for category in categories:\n            try:\n                cursor.execute(\n                    \"INSERT INTO categories (name) VALUES (?) \"\n                    \"ON CONFLICT(name) DO NOTHING\",\n                    (category,),\n                )\n                logging.info(f\"Categoria '{category}' inserida com sucesso.\")\n            except sqlite3.IntegrityError as e:\n                logging.error(f\"Erro ao inserir a categoria '{category}': {e}\")\n\n        conn.commit()\n        conn.close()\n        logging.info(\"Todas as categorias foram processadas e inseridas.\")\n</code></pre>"},{"location":"silver/silver_category_ingestion/#fake_store.silver_categories_ingestion.CategoryIngestion.__init__","title":"<code>__init__(db_path, json_path)</code>","text":"<p>Inicializa a conex\u00e3o com o banco de dados e o caminho do arquivo JSON. :param db_path: Caminho do banco de dados SQLite. :param json_path: Caminho do arquivo JSON com as categorias.</p> Source code in <code>fake_store/silver_categories_ingestion.py</code> <pre><code>def __init__(self, db_path: str, json_path: str):\n    \"\"\"\n    Inicializa a conex\u00e3o com o banco de dados e o caminho do arquivo JSON.\n    :param db_path: Caminho do banco de dados SQLite.\n    :param json_path: Caminho do arquivo JSON com as categorias.\n    \"\"\"\n    self.db_path = db_path\n    self.json_path = json_path\n</code></pre>"},{"location":"silver/silver_category_ingestion/#fake_store.silver_categories_ingestion.CategoryIngestion.insert_categories","title":"<code>insert_categories()</code>","text":"<p>Insere as categorias na tabela <code>categories</code>.</p> Source code in <code>fake_store/silver_categories_ingestion.py</code> <pre><code>def insert_categories(self):\n    \"\"\"Insere as categorias na tabela `categories`.\"\"\"\n    categories = self.load_json()\n\n    if not categories:\n        logging.warning(\"Nenhuma categoria encontrada para inser\u00e7\u00e3o.\")\n        return\n\n    conn = self._connect_db()\n    if conn is None:\n        logging.error(\n            \"Conex\u00e3o com o banco de dados n\u00e3o estabelecida.\"\n            // \"Abortando inser\u00e7\u00e3o.\"\n        )\n        return\n\n    cursor = conn.cursor()\n\n    for category in categories:\n        try:\n            cursor.execute(\n                \"INSERT INTO categories (name) VALUES (?) \"\n                \"ON CONFLICT(name) DO NOTHING\",\n                (category,),\n            )\n            logging.info(f\"Categoria '{category}' inserida com sucesso.\")\n        except sqlite3.IntegrityError as e:\n            logging.error(f\"Erro ao inserir a categoria '{category}': {e}\")\n\n    conn.commit()\n    conn.close()\n    logging.info(\"Todas as categorias foram processadas e inseridas.\")\n</code></pre>"},{"location":"silver/silver_category_ingestion/#fake_store.silver_categories_ingestion.CategoryIngestion.load_json","title":"<code>load_json()</code>","text":"<p>Carrega as categorias do arquivo JSON.</p> Source code in <code>fake_store/silver_categories_ingestion.py</code> <pre><code>def load_json(self):\n    \"\"\"Carrega as categorias do arquivo JSON.\"\"\"\n    try:\n        with open(self.json_path, \"r\", encoding=\"utf-8\") as file:\n            data = json.load(file)\n\n        logging.info(\"Conte\u00fado do JSON carregado com sucesso.\")\n        if isinstance(data, list) and data:\n            # Verifica se a primeira entrada cont\u00e9m a chave 'category'\n            if \"category\" in data[0]:\n                return data[0][\"category\"]\n            else:\n                logging.warning(\n                    \"A chave 'category' n\u00e3o encontrada na entrada JSON.\"\n                )\n        else:\n            logging.warning(\n                \"O JSON n\u00e3o cont\u00e9m uma lista v\u00e1lida ou est\u00e1 vazio.\"\n            )\n            return []\n\n    except json.JSONDecodeError as e:\n        logging.error(f\"Erro ao decodificar o JSON: {e}\")\n        return []\n    except FileNotFoundError:\n        logging.error(f\"Arquivo JSON n\u00e3o encontrado: {self.json_path}\")\n        return []\n</code></pre>"},{"location":"silver/silver_database/","title":"Cria\u00e7\u00e3o do banco de dados","text":""},{"location":"silver/silver_database/#fake_store.silver_database","title":"<code>fake_store.silver_database</code>","text":""},{"location":"silver/silver_database/#fake_store.silver_database.DatabaseSilver","title":"<code>DatabaseSilver</code>","text":"<p>Gerencia a conex\u00e3o e inicializa\u00e7\u00e3o do banco de dados.</p> Source code in <code>fake_store/silver_database.py</code> <pre><code>class DatabaseSilver:\n    \"\"\"\n    Gerencia a conex\u00e3o e inicializa\u00e7\u00e3o do banco de dados.\n    \"\"\"\n\n    def __init__(self, db_path=\"data/silver\", db_name=\"fake_store.db\"):\n        \"\"\"\n        Inicializa o gerenciador de banco de dados.\n\n        Args:\n            db_path (str): Caminho do diret\u00f3rio onde o arquivo do\n                           banco de dados ser\u00e1 salvo.\n            db_name (str): Nome do arquivo do banco de dados.\n        \"\"\"\n        self.db_path = db_path\n        self.db_name = db_name\n        self.conn = None\n        self.cursor = None\n\n    def connect(self):\n        \"\"\"Conecta ao banco de dados.\"\"\"\n        self.conn = sqlite3.connect(os.path.join(self.db_path, self.db_name))\n        self.cursor = self.conn.cursor()\n        logging.info(\"Conex\u00e3o estabelecida com o banco de dados.\")\n\n    def create_tables(self):\n        \"\"\"Cria as tabelas no banco de dados se ainda n\u00e3o foram criadas.\"\"\"\n        self.cursor.executescript(\"\"\"\n        CREATE TABLE IF NOT EXISTS categories (\n            id INTEGER PRIMARY KEY AUTOINCREMENT,\n            name TEXT NOT NULL UNIQUE\n        );\n\n        CREATE TABLE IF NOT EXISTS products (\n            id INTEGER PRIMARY KEY AUTOINCREMENT,\n            title TEXT NOT NULL,\n            price REAL NOT NULL,\n            description TEXT NOT NULL,\n            category_id INTEGER NOT NULL,\n            FOREIGN KEY (category_id) REFERENCES categories(id)\n        );\n\n        CREATE TABLE IF NOT EXISTS geolocation (\n            id INTEGER PRIMARY KEY AUTOINCREMENT,\n            lat TEXT NOT NULL,\n            long TEXT NOT NULL\n        );\n\n        CREATE TABLE IF NOT EXISTS addresses (\n            id INTEGER PRIMARY KEY AUTOINCREMENT,\n            city TEXT NOT NULL,\n            street TEXT NOT NULL,\n            number INTEGER NOT NULL,\n            zipcode TEXT NOT NULL,\n            geolocation_id INTEGER NOT NULL,\n            FOREIGN KEY (geolocation_id) REFERENCES geolocation(id)\n        );\n\n        CREATE TABLE IF NOT EXISTS names (\n            id INTEGER PRIMARY KEY AUTOINCREMENT,\n            firstname TEXT NOT NULL,\n            lastname TEXT NOT NULL\n        );\n\n        CREATE TABLE IF NOT EXISTS users (\n            id INTEGER PRIMARY KEY AUTOINCREMENT,\n            email TEXT NOT NULL UNIQUE,\n            username TEXT NOT NULL UNIQUE,\n            password TEXT NOT NULL,\n            name_id INTEGER NOT NULL,\n            address_id INTEGER NOT NULL,\n            phone TEXT NOT NULL,\n            FOREIGN KEY (name_id) REFERENCES names(id),\n            FOREIGN KEY (address_id) REFERENCES addresses(id)\n        );\n\n        CREATE TABLE IF NOT EXISTS carts (\n            id INTEGER PRIMARY KEY AUTOINCREMENT,\n            user_id INTEGER NOT NULL,\n            date TEXT NOT NULL,\n            FOREIGN KEY (user_id) REFERENCES users(id)\n        );\n\n        CREATE TABLE IF NOT EXISTS cart_products (\n            cart_id INTEGER NOT NULL,\n            product_id INTEGER NOT NULL,\n            quantity INTEGER NOT NULL,\n            PRIMARY KEY (cart_id, product_id),\n            FOREIGN KEY (cart_id) REFERENCES carts(id),\n            FOREIGN KEY (product_id) REFERENCES products(id)\n        );\n        \"\"\")\n        self.conn.commit()\n        logging.info(\"Tabelas criadas ou j\u00e1 existem no banco de dados.\")\n\n    def initialize_database(self):\n        \"\"\"\n        Inicializa o banco de dados verificando se o arquivo j\u00e1 existe.\n        Se o arquivo n\u00e3o existir, cria as tabelas.\n        \"\"\"\n        full_db_path = os.path.join(self.db_path, self.db_name)\n        if not os.path.isfile(full_db_path):\n            logging.info(\n                f\"Criando o banco de dados {self.db_name} em {self.db_path}...\"\n            )\n            self.connect()\n            self.create_tables()\n            logging.info(\"Banco de dados criado com sucesso.\")\n        else:\n            logging.info(f\"Conectando ao banco de dados {full_db_path}.\")\n            self.connect()\n\n    def close(self):\n        \"\"\"Fecha a conex\u00e3o com o banco de dados.\"\"\"\n        if self.conn:\n            self.conn.close()\n            logging.info(\"Conex\u00e3o com o banco de dados fechada.\")\n</code></pre>"},{"location":"silver/silver_database/#fake_store.silver_database.DatabaseSilver.__init__","title":"<code>__init__(db_path='data/silver', db_name='fake_store.db')</code>","text":"<p>Inicializa o gerenciador de banco de dados.</p> <p>Parameters:</p> Name Type Description Default <code>db_path</code> <code>str</code> <p>Caminho do diret\u00f3rio onde o arquivo do            banco de dados ser\u00e1 salvo.</p> <code>'data/silver'</code> <code>db_name</code> <code>str</code> <p>Nome do arquivo do banco de dados.</p> <code>'fake_store.db'</code> Source code in <code>fake_store/silver_database.py</code> <pre><code>def __init__(self, db_path=\"data/silver\", db_name=\"fake_store.db\"):\n    \"\"\"\n    Inicializa o gerenciador de banco de dados.\n\n    Args:\n        db_path (str): Caminho do diret\u00f3rio onde o arquivo do\n                       banco de dados ser\u00e1 salvo.\n        db_name (str): Nome do arquivo do banco de dados.\n    \"\"\"\n    self.db_path = db_path\n    self.db_name = db_name\n    self.conn = None\n    self.cursor = None\n</code></pre>"},{"location":"silver/silver_database/#fake_store.silver_database.DatabaseSilver.close","title":"<code>close()</code>","text":"<p>Fecha a conex\u00e3o com o banco de dados.</p> Source code in <code>fake_store/silver_database.py</code> <pre><code>def close(self):\n    \"\"\"Fecha a conex\u00e3o com o banco de dados.\"\"\"\n    if self.conn:\n        self.conn.close()\n        logging.info(\"Conex\u00e3o com o banco de dados fechada.\")\n</code></pre>"},{"location":"silver/silver_database/#fake_store.silver_database.DatabaseSilver.connect","title":"<code>connect()</code>","text":"<p>Conecta ao banco de dados.</p> Source code in <code>fake_store/silver_database.py</code> <pre><code>def connect(self):\n    \"\"\"Conecta ao banco de dados.\"\"\"\n    self.conn = sqlite3.connect(os.path.join(self.db_path, self.db_name))\n    self.cursor = self.conn.cursor()\n    logging.info(\"Conex\u00e3o estabelecida com o banco de dados.\")\n</code></pre>"},{"location":"silver/silver_database/#fake_store.silver_database.DatabaseSilver.create_tables","title":"<code>create_tables()</code>","text":"<p>Cria as tabelas no banco de dados se ainda n\u00e3o foram criadas.</p> Source code in <code>fake_store/silver_database.py</code> <pre><code>def create_tables(self):\n    \"\"\"Cria as tabelas no banco de dados se ainda n\u00e3o foram criadas.\"\"\"\n    self.cursor.executescript(\"\"\"\n    CREATE TABLE IF NOT EXISTS categories (\n        id INTEGER PRIMARY KEY AUTOINCREMENT,\n        name TEXT NOT NULL UNIQUE\n    );\n\n    CREATE TABLE IF NOT EXISTS products (\n        id INTEGER PRIMARY KEY AUTOINCREMENT,\n        title TEXT NOT NULL,\n        price REAL NOT NULL,\n        description TEXT NOT NULL,\n        category_id INTEGER NOT NULL,\n        FOREIGN KEY (category_id) REFERENCES categories(id)\n    );\n\n    CREATE TABLE IF NOT EXISTS geolocation (\n        id INTEGER PRIMARY KEY AUTOINCREMENT,\n        lat TEXT NOT NULL,\n        long TEXT NOT NULL\n    );\n\n    CREATE TABLE IF NOT EXISTS addresses (\n        id INTEGER PRIMARY KEY AUTOINCREMENT,\n        city TEXT NOT NULL,\n        street TEXT NOT NULL,\n        number INTEGER NOT NULL,\n        zipcode TEXT NOT NULL,\n        geolocation_id INTEGER NOT NULL,\n        FOREIGN KEY (geolocation_id) REFERENCES geolocation(id)\n    );\n\n    CREATE TABLE IF NOT EXISTS names (\n        id INTEGER PRIMARY KEY AUTOINCREMENT,\n        firstname TEXT NOT NULL,\n        lastname TEXT NOT NULL\n    );\n\n    CREATE TABLE IF NOT EXISTS users (\n        id INTEGER PRIMARY KEY AUTOINCREMENT,\n        email TEXT NOT NULL UNIQUE,\n        username TEXT NOT NULL UNIQUE,\n        password TEXT NOT NULL,\n        name_id INTEGER NOT NULL,\n        address_id INTEGER NOT NULL,\n        phone TEXT NOT NULL,\n        FOREIGN KEY (name_id) REFERENCES names(id),\n        FOREIGN KEY (address_id) REFERENCES addresses(id)\n    );\n\n    CREATE TABLE IF NOT EXISTS carts (\n        id INTEGER PRIMARY KEY AUTOINCREMENT,\n        user_id INTEGER NOT NULL,\n        date TEXT NOT NULL,\n        FOREIGN KEY (user_id) REFERENCES users(id)\n    );\n\n    CREATE TABLE IF NOT EXISTS cart_products (\n        cart_id INTEGER NOT NULL,\n        product_id INTEGER NOT NULL,\n        quantity INTEGER NOT NULL,\n        PRIMARY KEY (cart_id, product_id),\n        FOREIGN KEY (cart_id) REFERENCES carts(id),\n        FOREIGN KEY (product_id) REFERENCES products(id)\n    );\n    \"\"\")\n    self.conn.commit()\n    logging.info(\"Tabelas criadas ou j\u00e1 existem no banco de dados.\")\n</code></pre>"},{"location":"silver/silver_database/#fake_store.silver_database.DatabaseSilver.initialize_database","title":"<code>initialize_database()</code>","text":"<p>Inicializa o banco de dados verificando se o arquivo j\u00e1 existe. Se o arquivo n\u00e3o existir, cria as tabelas.</p> Source code in <code>fake_store/silver_database.py</code> <pre><code>def initialize_database(self):\n    \"\"\"\n    Inicializa o banco de dados verificando se o arquivo j\u00e1 existe.\n    Se o arquivo n\u00e3o existir, cria as tabelas.\n    \"\"\"\n    full_db_path = os.path.join(self.db_path, self.db_name)\n    if not os.path.isfile(full_db_path):\n        logging.info(\n            f\"Criando o banco de dados {self.db_name} em {self.db_path}...\"\n        )\n        self.connect()\n        self.create_tables()\n        logging.info(\"Banco de dados criado com sucesso.\")\n    else:\n        logging.info(f\"Conectando ao banco de dados {full_db_path}.\")\n        self.connect()\n</code></pre>"},{"location":"silver/silver_products_ingestion/","title":"Ingest\u00e3o de dados de produtos","text":""},{"location":"silver/silver_products_ingestion/#fake_store.silver_products_ingestion","title":"<code>fake_store.silver_products_ingestion</code>","text":""},{"location":"silver/silver_products_ingestion/#fake_store.silver_products_ingestion.ProductIngestion","title":"<code>ProductIngestion</code>","text":"<p>Classe para ingerir produtos em um banco de dados SQLite.</p> Source code in <code>fake_store/silver_products_ingestion.py</code> <pre><code>class ProductIngestion:\n    \"\"\"Classe para ingerir produtos em um banco de dados SQLite.\"\"\"\n\n    def __init__(self, db_file, json_file):\n        \"\"\"Inicializa a classe com o caminho do banco de dados\n        e do arquivo JSON.\n\n        Args:\n            db_file (str): Caminho do arquivo de banco de dados SQLite.\n            json_file (str): Caminho do arquivo JSON com dados dos produtos.\n        \"\"\"\n        self.connection = sqlite3.connect(db_file)\n        self.cursor = self.connection.cursor()\n        self.json_file = json_file\n\n    @staticmethod\n    def fetch_products_from_file(file_path):\n        \"\"\"Carrega produtos de um arquivo JSON.\n\n        Args:\n            file_path (str): Caminho do arquivo JSON com dados dos produtos.\n\n        Returns:\n            list: Lista de produtos carregados do arquivo JSON.\n        \"\"\"\n        with open(file_path, \"r\", encoding=\"utf-8\") as f:\n            return json.load(f)\n\n    def fetch_categories(self):\n        \"\"\"Recupera todas as categorias do banco de dados.\n\n        Returns:\n            dict: Um dicion\u00e1rio com o nome da\n            categoria como chave e seu ID como valor.\n        \"\"\"\n        self.cursor.execute(\"SELECT id, name FROM categories\")\n        return {name: id for id, name in self.cursor.fetchall()}\n\n    def insert_products(self):\n        \"\"\"Insere produtos no banco de dados, evitando duplicatas.\"\"\"\n        categories = self.fetch_categories()\n        products = self.fetch_products_from_file(self.json_file)\n\n        for product in products:\n            title = product[\"title\"]\n            price = product[\"price\"]\n            description = product[\"description\"]\n            category_name = product[\"category\"]\n\n            category_id = categories.get(category_name)\n            if category_id is not None:\n                self.cursor.execute(\n                    \"\"\"\n                        SELECT id FROM products\n                            WHERE title = ? AND category_id = ?\n                    \"\"\",\n                    (title, category_id),\n                )\n                existing_product = self.cursor.fetchone()\n\n                if existing_product is None:\n                    self.cursor.execute(\n                        \"\"\"\n                        INSERT INTO products\n                            (title, price, description, category_id)\n                            VALUES (?, ?, ?, ?)\n                        \"\"\",\n                        (title, price, description, category_id),\n                    )\n                    logging.info(f\"Produto '{title}' inserido com sucesso.\")\n                else:\n                    logging.info(\n                        f\"Produto '{title}' j\u00e1 existe no banco de dados.\"\n                    )\n            else:\n                logging.warning(\n                    f\"\"\"Categoria '{category_name}'\n                    n\u00e3o encontrada para o produto '{title}'.\"\"\"\n                )\n\n        self.connection.commit()\n\n    def close(self):\n        \"\"\"Fecha a conex\u00e3o com o banco de dados.\"\"\"\n        self.connection.close()\n</code></pre>"},{"location":"silver/silver_products_ingestion/#fake_store.silver_products_ingestion.ProductIngestion.__init__","title":"<code>__init__(db_file, json_file)</code>","text":"<p>Inicializa a classe com o caminho do banco de dados e do arquivo JSON.</p> <p>Parameters:</p> Name Type Description Default <code>db_file</code> <code>str</code> <p>Caminho do arquivo de banco de dados SQLite.</p> required <code>json_file</code> <code>str</code> <p>Caminho do arquivo JSON com dados dos produtos.</p> required Source code in <code>fake_store/silver_products_ingestion.py</code> <pre><code>def __init__(self, db_file, json_file):\n    \"\"\"Inicializa a classe com o caminho do banco de dados\n    e do arquivo JSON.\n\n    Args:\n        db_file (str): Caminho do arquivo de banco de dados SQLite.\n        json_file (str): Caminho do arquivo JSON com dados dos produtos.\n    \"\"\"\n    self.connection = sqlite3.connect(db_file)\n    self.cursor = self.connection.cursor()\n    self.json_file = json_file\n</code></pre>"},{"location":"silver/silver_products_ingestion/#fake_store.silver_products_ingestion.ProductIngestion.close","title":"<code>close()</code>","text":"<p>Fecha a conex\u00e3o com o banco de dados.</p> Source code in <code>fake_store/silver_products_ingestion.py</code> <pre><code>def close(self):\n    \"\"\"Fecha a conex\u00e3o com o banco de dados.\"\"\"\n    self.connection.close()\n</code></pre>"},{"location":"silver/silver_products_ingestion/#fake_store.silver_products_ingestion.ProductIngestion.fetch_categories","title":"<code>fetch_categories()</code>","text":"<p>Recupera todas as categorias do banco de dados.</p> <p>Returns:</p> Name Type Description <code>dict</code> <p>Um dicion\u00e1rio com o nome da</p> <p>categoria como chave e seu ID como valor.</p> Source code in <code>fake_store/silver_products_ingestion.py</code> <pre><code>def fetch_categories(self):\n    \"\"\"Recupera todas as categorias do banco de dados.\n\n    Returns:\n        dict: Um dicion\u00e1rio com o nome da\n        categoria como chave e seu ID como valor.\n    \"\"\"\n    self.cursor.execute(\"SELECT id, name FROM categories\")\n    return {name: id for id, name in self.cursor.fetchall()}\n</code></pre>"},{"location":"silver/silver_products_ingestion/#fake_store.silver_products_ingestion.ProductIngestion.fetch_products_from_file","title":"<code>fetch_products_from_file(file_path)</code>  <code>staticmethod</code>","text":"<p>Carrega produtos de um arquivo JSON.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>str</code> <p>Caminho do arquivo JSON com dados dos produtos.</p> required <p>Returns:</p> Name Type Description <code>list</code> <p>Lista de produtos carregados do arquivo JSON.</p> Source code in <code>fake_store/silver_products_ingestion.py</code> <pre><code>@staticmethod\ndef fetch_products_from_file(file_path):\n    \"\"\"Carrega produtos de um arquivo JSON.\n\n    Args:\n        file_path (str): Caminho do arquivo JSON com dados dos produtos.\n\n    Returns:\n        list: Lista de produtos carregados do arquivo JSON.\n    \"\"\"\n    with open(file_path, \"r\", encoding=\"utf-8\") as f:\n        return json.load(f)\n</code></pre>"},{"location":"silver/silver_products_ingestion/#fake_store.silver_products_ingestion.ProductIngestion.insert_products","title":"<code>insert_products()</code>","text":"<p>Insere produtos no banco de dados, evitando duplicatas.</p> Source code in <code>fake_store/silver_products_ingestion.py</code> <pre><code>def insert_products(self):\n    \"\"\"Insere produtos no banco de dados, evitando duplicatas.\"\"\"\n    categories = self.fetch_categories()\n    products = self.fetch_products_from_file(self.json_file)\n\n    for product in products:\n        title = product[\"title\"]\n        price = product[\"price\"]\n        description = product[\"description\"]\n        category_name = product[\"category\"]\n\n        category_id = categories.get(category_name)\n        if category_id is not None:\n            self.cursor.execute(\n                \"\"\"\n                    SELECT id FROM products\n                        WHERE title = ? AND category_id = ?\n                \"\"\",\n                (title, category_id),\n            )\n            existing_product = self.cursor.fetchone()\n\n            if existing_product is None:\n                self.cursor.execute(\n                    \"\"\"\n                    INSERT INTO products\n                        (title, price, description, category_id)\n                        VALUES (?, ?, ?, ?)\n                    \"\"\",\n                    (title, price, description, category_id),\n                )\n                logging.info(f\"Produto '{title}' inserido com sucesso.\")\n            else:\n                logging.info(\n                    f\"Produto '{title}' j\u00e1 existe no banco de dados.\"\n                )\n        else:\n            logging.warning(\n                f\"\"\"Categoria '{category_name}'\n                n\u00e3o encontrada para o produto '{title}'.\"\"\"\n            )\n\n    self.connection.commit()\n</code></pre>"},{"location":"silver/silver_user_ingestion/","title":"Ingest\u00e3o de dados de usu\u00e1rios","text":""},{"location":"silver/silver_user_ingestion/#fake_store.silver_user_ingestion","title":"<code>fake_store.silver_user_ingestion</code>","text":""},{"location":"silver/silver_user_ingestion/#fake_store.silver_user_ingestion.UserIngestion","title":"<code>UserIngestion</code>","text":"<p>Classe para ingerir usu\u00e1rios em um banco de dados SQLite.</p> Source code in <code>fake_store/silver_user_ingestion.py</code> <pre><code>class UserIngestion:\n    \"\"\"Classe para ingerir usu\u00e1rios em um banco de dados SQLite.\"\"\"\n\n    def __init__(self, db_path, json_path):\n        \"\"\"Inicializa a classe com o caminho do banco e do arquivo JSON.\n\n        Args:\n            db_path (str): Caminho do arquivo de banco de dados SQLite.\n            json_path (str): Caminho do arquivo JSON com dados dos usu\u00e1rios.\n        \"\"\"\n        self.db_path = db_path\n        self.json_path = json_path\n        self.users_data = []\n\n    def load_data(self):\n        \"\"\"Carrega os dados dos usu\u00e1rios a partir do arquivo JSON.\"\"\"\n        with open(self.json_path, \"r\", encoding=\"utf-8\") as file:\n            self.users_data = json.load(file)\n\n    @classmethod\n    def insert_geolocation(cls, cursor, geolocation):\n        \"\"\"Insere a geolocaliza\u00e7\u00e3o no banco de dados.\n\n        Args:\n            cursor: O cursor do banco de dados.\n            geolocation (dict): Dados de geolocaliza\u00e7\u00e3o.\n\n        Returns:\n            int: ID da geolocaliza\u00e7\u00e3o inserida.\n        \"\"\"\n        cursor.execute(\n            \"INSERT INTO geolocation (lat, long) VALUES (?, ?)\",\n            (geolocation[\"lat\"], geolocation[\"long\"]),\n        )\n        return cursor.lastrowid\n\n    @classmethod\n    def insert_address(cls, cursor, address_data):\n        \"\"\"Insere o endere\u00e7o no banco de dados.\n\n        Args:\n            cursor: O cursor do banco de dados.\n            address_data (dict): Dados do endere\u00e7o.\n\n        Returns:\n            int: ID do endere\u00e7o inserido.\n        \"\"\"\n        cursor.execute(\n            \"INSERT INTO addresses \"\n            \"(city, street, number, zipcode, geolocation_id) \"\n            \"VALUES (?, ?, ?, ?, ?)\",\n            (\n                address_data[\"city\"],\n                address_data[\"street\"],\n                address_data[\"number\"],\n                address_data[\"zipcode\"],\n                address_data[\"geolocation_id\"],\n            ),\n        )\n        return cursor.lastrowid\n\n    @classmethod\n    def insert_name(cls, cursor, name_data):\n        \"\"\"Insere o nome no banco de dados.\n\n        Args:\n            cursor: O cursor do banco de dados.\n            name_data (dict): Dados do nome.\n\n        Returns:\n            int: ID do nome inserido.\n        \"\"\"\n        cursor.execute(\n            \"INSERT INTO names (firstname, lastname) VALUES (?, ?)\",\n            (name_data[\"firstname\"], name_data[\"lastname\"]),\n        )\n        return cursor.lastrowid\n\n    @classmethod\n    def insert_user(cls, cursor, user_data):\n        \"\"\"Insere o usu\u00e1rio no banco de dados.\n\n        Args:\n            cursor: O cursor do banco de dados.\n            user_data (dict): Dados do usu\u00e1rio.\n        \"\"\"\n        cursor.execute(\n            \"INSERT INTO users\"\n            \"(email, username, password, name_id, address_id, phone) \"\n            \"VALUES (?, ?, ?, ?, ?, ?)\",\n            (\n                user_data[\"email\"],\n                user_data[\"username\"],\n                user_data[\"password\"],\n                user_data[\"name_id\"],\n                user_data[\"address_id\"],\n                user_data[\"phone\"],\n            ),\n        )\n        logging.info(\n            f\"Usu\u00e1rio '{user_data['username']}' inserido com sucesso.\"\n        )\n\n    def ingest_data(self):\n        \"\"\"Realiza a ingest\u00e3o de dados dos usu\u00e1rios no banco de dados.\"\"\"\n        self.load_data()\n        connection = sqlite3.connect(self.db_path)\n        cursor = connection.cursor()\n\n        try:\n            for user in self.users_data:\n                cursor.execute(\n                    \"SELECT id FROM users WHERE email = ?\", (user[\"email\"],)\n                )\n                if cursor.fetchone() is not None:\n                    logging.warning(\n                        f\"Usu\u00e1rio '{user['email']}' j\u00e1 existe no banco.\"\n                    )\n                    continue\n\n                geolocation_id = self.insert_geolocation(\n                    cursor, user[\"address\"][\"geolocation\"]\n                )\n\n                address_data = user[\"address\"]\n                address_data[\"geolocation_id\"] = geolocation_id\n                address_id = self.insert_address(cursor, address_data)\n\n                name_id = self.insert_name(cursor, user[\"name\"])\n\n                user_data = {\n                    \"email\": user[\"email\"],\n                    \"username\": user[\"username\"],\n                    \"password\": user[\"password\"],\n                    \"name_id\": name_id,\n                    \"address_id\": address_id,\n                    \"phone\": user[\"phone\"],\n                }\n                self.insert_user(cursor, user_data)\n\n            connection.commit()\n        except sqlite3.Error as e:\n            connection.rollback()\n            logging.error(\"Erro ao inserir dados: %s\", e)\n        finally:\n            connection.close()\n</code></pre>"},{"location":"silver/silver_user_ingestion/#fake_store.silver_user_ingestion.UserIngestion.__init__","title":"<code>__init__(db_path, json_path)</code>","text":"<p>Inicializa a classe com o caminho do banco e do arquivo JSON.</p> <p>Parameters:</p> Name Type Description Default <code>db_path</code> <code>str</code> <p>Caminho do arquivo de banco de dados SQLite.</p> required <code>json_path</code> <code>str</code> <p>Caminho do arquivo JSON com dados dos usu\u00e1rios.</p> required Source code in <code>fake_store/silver_user_ingestion.py</code> <pre><code>def __init__(self, db_path, json_path):\n    \"\"\"Inicializa a classe com o caminho do banco e do arquivo JSON.\n\n    Args:\n        db_path (str): Caminho do arquivo de banco de dados SQLite.\n        json_path (str): Caminho do arquivo JSON com dados dos usu\u00e1rios.\n    \"\"\"\n    self.db_path = db_path\n    self.json_path = json_path\n    self.users_data = []\n</code></pre>"},{"location":"silver/silver_user_ingestion/#fake_store.silver_user_ingestion.UserIngestion.ingest_data","title":"<code>ingest_data()</code>","text":"<p>Realiza a ingest\u00e3o de dados dos usu\u00e1rios no banco de dados.</p> Source code in <code>fake_store/silver_user_ingestion.py</code> <pre><code>def ingest_data(self):\n    \"\"\"Realiza a ingest\u00e3o de dados dos usu\u00e1rios no banco de dados.\"\"\"\n    self.load_data()\n    connection = sqlite3.connect(self.db_path)\n    cursor = connection.cursor()\n\n    try:\n        for user in self.users_data:\n            cursor.execute(\n                \"SELECT id FROM users WHERE email = ?\", (user[\"email\"],)\n            )\n            if cursor.fetchone() is not None:\n                logging.warning(\n                    f\"Usu\u00e1rio '{user['email']}' j\u00e1 existe no banco.\"\n                )\n                continue\n\n            geolocation_id = self.insert_geolocation(\n                cursor, user[\"address\"][\"geolocation\"]\n            )\n\n            address_data = user[\"address\"]\n            address_data[\"geolocation_id\"] = geolocation_id\n            address_id = self.insert_address(cursor, address_data)\n\n            name_id = self.insert_name(cursor, user[\"name\"])\n\n            user_data = {\n                \"email\": user[\"email\"],\n                \"username\": user[\"username\"],\n                \"password\": user[\"password\"],\n                \"name_id\": name_id,\n                \"address_id\": address_id,\n                \"phone\": user[\"phone\"],\n            }\n            self.insert_user(cursor, user_data)\n\n        connection.commit()\n    except sqlite3.Error as e:\n        connection.rollback()\n        logging.error(\"Erro ao inserir dados: %s\", e)\n    finally:\n        connection.close()\n</code></pre>"},{"location":"silver/silver_user_ingestion/#fake_store.silver_user_ingestion.UserIngestion.insert_address","title":"<code>insert_address(cursor, address_data)</code>  <code>classmethod</code>","text":"<p>Insere o endere\u00e7o no banco de dados.</p> <p>Parameters:</p> Name Type Description Default <code>cursor</code> <p>O cursor do banco de dados.</p> required <code>address_data</code> <code>dict</code> <p>Dados do endere\u00e7o.</p> required <p>Returns:</p> Name Type Description <code>int</code> <p>ID do endere\u00e7o inserido.</p> Source code in <code>fake_store/silver_user_ingestion.py</code> <pre><code>@classmethod\ndef insert_address(cls, cursor, address_data):\n    \"\"\"Insere o endere\u00e7o no banco de dados.\n\n    Args:\n        cursor: O cursor do banco de dados.\n        address_data (dict): Dados do endere\u00e7o.\n\n    Returns:\n        int: ID do endere\u00e7o inserido.\n    \"\"\"\n    cursor.execute(\n        \"INSERT INTO addresses \"\n        \"(city, street, number, zipcode, geolocation_id) \"\n        \"VALUES (?, ?, ?, ?, ?)\",\n        (\n            address_data[\"city\"],\n            address_data[\"street\"],\n            address_data[\"number\"],\n            address_data[\"zipcode\"],\n            address_data[\"geolocation_id\"],\n        ),\n    )\n    return cursor.lastrowid\n</code></pre>"},{"location":"silver/silver_user_ingestion/#fake_store.silver_user_ingestion.UserIngestion.insert_geolocation","title":"<code>insert_geolocation(cursor, geolocation)</code>  <code>classmethod</code>","text":"<p>Insere a geolocaliza\u00e7\u00e3o no banco de dados.</p> <p>Parameters:</p> Name Type Description Default <code>cursor</code> <p>O cursor do banco de dados.</p> required <code>geolocation</code> <code>dict</code> <p>Dados de geolocaliza\u00e7\u00e3o.</p> required <p>Returns:</p> Name Type Description <code>int</code> <p>ID da geolocaliza\u00e7\u00e3o inserida.</p> Source code in <code>fake_store/silver_user_ingestion.py</code> <pre><code>@classmethod\ndef insert_geolocation(cls, cursor, geolocation):\n    \"\"\"Insere a geolocaliza\u00e7\u00e3o no banco de dados.\n\n    Args:\n        cursor: O cursor do banco de dados.\n        geolocation (dict): Dados de geolocaliza\u00e7\u00e3o.\n\n    Returns:\n        int: ID da geolocaliza\u00e7\u00e3o inserida.\n    \"\"\"\n    cursor.execute(\n        \"INSERT INTO geolocation (lat, long) VALUES (?, ?)\",\n        (geolocation[\"lat\"], geolocation[\"long\"]),\n    )\n    return cursor.lastrowid\n</code></pre>"},{"location":"silver/silver_user_ingestion/#fake_store.silver_user_ingestion.UserIngestion.insert_name","title":"<code>insert_name(cursor, name_data)</code>  <code>classmethod</code>","text":"<p>Insere o nome no banco de dados.</p> <p>Parameters:</p> Name Type Description Default <code>cursor</code> <p>O cursor do banco de dados.</p> required <code>name_data</code> <code>dict</code> <p>Dados do nome.</p> required <p>Returns:</p> Name Type Description <code>int</code> <p>ID do nome inserido.</p> Source code in <code>fake_store/silver_user_ingestion.py</code> <pre><code>@classmethod\ndef insert_name(cls, cursor, name_data):\n    \"\"\"Insere o nome no banco de dados.\n\n    Args:\n        cursor: O cursor do banco de dados.\n        name_data (dict): Dados do nome.\n\n    Returns:\n        int: ID do nome inserido.\n    \"\"\"\n    cursor.execute(\n        \"INSERT INTO names (firstname, lastname) VALUES (?, ?)\",\n        (name_data[\"firstname\"], name_data[\"lastname\"]),\n    )\n    return cursor.lastrowid\n</code></pre>"},{"location":"silver/silver_user_ingestion/#fake_store.silver_user_ingestion.UserIngestion.insert_user","title":"<code>insert_user(cursor, user_data)</code>  <code>classmethod</code>","text":"<p>Insere o usu\u00e1rio no banco de dados.</p> <p>Parameters:</p> Name Type Description Default <code>cursor</code> <p>O cursor do banco de dados.</p> required <code>user_data</code> <code>dict</code> <p>Dados do usu\u00e1rio.</p> required Source code in <code>fake_store/silver_user_ingestion.py</code> <pre><code>@classmethod\ndef insert_user(cls, cursor, user_data):\n    \"\"\"Insere o usu\u00e1rio no banco de dados.\n\n    Args:\n        cursor: O cursor do banco de dados.\n        user_data (dict): Dados do usu\u00e1rio.\n    \"\"\"\n    cursor.execute(\n        \"INSERT INTO users\"\n        \"(email, username, password, name_id, address_id, phone) \"\n        \"VALUES (?, ?, ?, ?, ?, ?)\",\n        (\n            user_data[\"email\"],\n            user_data[\"username\"],\n            user_data[\"password\"],\n            user_data[\"name_id\"],\n            user_data[\"address_id\"],\n            user_data[\"phone\"],\n        ),\n    )\n    logging.info(\n        f\"Usu\u00e1rio '{user_data['username']}' inserido com sucesso.\"\n    )\n</code></pre>"},{"location":"silver/silver_user_ingestion/#fake_store.silver_user_ingestion.UserIngestion.load_data","title":"<code>load_data()</code>","text":"<p>Carrega os dados dos usu\u00e1rios a partir do arquivo JSON.</p> Source code in <code>fake_store/silver_user_ingestion.py</code> <pre><code>def load_data(self):\n    \"\"\"Carrega os dados dos usu\u00e1rios a partir do arquivo JSON.\"\"\"\n    with open(self.json_path, \"r\", encoding=\"utf-8\") as file:\n        self.users_data = json.load(file)\n</code></pre>"}]}